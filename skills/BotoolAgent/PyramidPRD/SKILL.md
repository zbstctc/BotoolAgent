---
name: botoolagent-pyramidprd
description: "金字塔式 PRD 问答生成器。通过 6 层递进式问答（L0 方向探索 + L1-L5 含 ASCII 可视化确认门控）收集需求，生成多维度高颗粒度 PRD 文档。触发词：pyramid prd, 金字塔问答, 层级问答"
user-invocable: true
---

# BotoolAgent 金字塔 PRD 生成器

通过 6 层递进式问答（L0 方向探索 + L1-L5 含 ASCII 可视化确认门控），系统性地收集需求并生成**多维度、高颗粒度** PRD 文档。

**启动提示:** "Using BotoolAgent:PyramidPRD to collect requirements through structured Q&A."

---

## 重要：所有内容必须使用中文

所有问题、选项、描述、反馈都必须使用中文。

---

## 金字塔结构概述

```
评估复杂度 → 确定问题数量 → 选择模式
    ↓
L0: 方向探索 - 项目上下文扫描 + 需求方向理解 + 方案选择 + 范围确认
    ↓  → Write qa-journal.md §L0
    ↓  （用户明确说不需要时跳过）
L1: 核心识别 - 理解需求本质（Read journal → 方案卡 → Write journal §L1）
    ↓
S1: 代码库扫描 → Task(Explore) subagent → codebase-scan.md
    ↓
R1: 规范确认 - 扫描 rules/ 目录，用户确认适用规范 → Write journal §R1
    ↓
L2: 领域分支 - Read journal → 方案卡 → Write journal §L2
    ↓
L3: 细节深入 - Read journal → 方案卡 → Write journal §L3
    ↓
L4: 边界确认 - Read journal → 方案卡 → Write journal §L4
    ↓
Phase 5.5: 外部依赖扫描
    ↓
Phase 5.8: Compact 检查点（用户可选压缩对话后继续）
    ↓
L5: 确认门控 - ASCII 多维度可视化确认（架构/数据/UI/规则/计划）
    ↓
G1/W1: PRD 生成 → Task(general-purpose) subagent → prd.md
    ↓
PRDing Ralph 后台编排（A1 自动审查 → A2 自动转换）
```

### Q&A Journal 持久化机制

**每层结束后 Write journal → 下层开始时 Read journal 恢复上下文。**

Journal 文件路径：`$TASKS_DIR/<projectId>/qa-journal.md`

上下文从线性累积 ~150KB 降至 journal ~3KB + 当前层 ~5KB。

**Journal 格式：**

```markdown
# Q&A Journal — [项目名]
> 模式: 功能开发 | 复杂度: 中等

## L0 方向探索
- 选定方向: [方向 + 一句话说明]
- 实现思路: [技术方案]
- 范围: ✅ [要做] / ❌ [不做]
- 技术栈: [框架 + 语言 + DB]

## S1 代码扫描摘要
- 技术栈: [Subagent 产出摘要]
- 关键模块: [组件列表]
- 已有 API: [端点列表]

## R1 规范确认
- 已确认规范: [rules/ 扫描结果]
- 排除: [不适用的规范]

## L1 核心识别
- Q1: [问题] → [选定答案]
- Q2: [问题] → [选定答案]
...

## L2 领域分支
...

## L3 细节深入
...

## L4 边界确认
...
```

**写入时机：** 每层用户确认后立即 Write（追加模式，不覆盖前序层级）。
**读取时机：** 每层开始前 Read 全部 journal 内容作为上下文输入。

---

## 动态复杂度评估

**收到需求描述后，首先评估复杂度，决定每层问多少问题。**

### 复杂度判断标准

| 复杂度 | 特征 | 每层问题数 | 示例 |
|--------|------|-----------|------|
| **简单** | 单一功能、单一用户、无后端 | 3-4 个 | "做个计数器"、"添加深色模式" |
| **中等** | 多个功能点、需要后端、有数据存储 | 5-7 个 | "用户登录功能"、"数据导出" |
| **复杂** | 多角色、多模块、复杂业务逻辑 | 8-12 个 | "用户管理系统"、"订单流程" |

### 复杂度信号

**简单需求信号：**
- 描述少于 10 个字
- 只提到一个功能点
- 明确说"简单"、"基础"、"MVP"

**中等需求信号：**
- 涉及前后端
- 需要数据持久化
- 有 2-3 个功能点

**复杂需求信号：**
- 涉及多个用户角色
- 有复杂的业务流程
- 需要与多个系统集成
- 描述中有"系统"、"平台"、"管理"等词

### 在 metadata 中标注复杂度

```json
{
  "metadata": {
    "source": "pyramidprd",
    "level": 1,
    "complexity": "medium",
    "questionsPerLevel": "5-7"
  }
}
```

---

## 核心规则：使用 AskUserQuestion 批量提问

**每次调用 AskUserQuestion 时，必须在 metadata 中包含 level 信息！**

```json
{
  "questions": [...],
  "metadata": {
    "source": "pyramidprd",
    "level": 1,
    "levelName": "L1: 核心识别",
    "progress": "2/6",
    "totalLevels": 6,
    "codebaseScanned": false
  }
}
```

**问题格式要求：**
- **必须根据复杂度决定问题数量**（见上方复杂度评估）
- 每个问题第一行标注层级：`【L1: 核心识别】问题内容`
- options 要有 label 和 description
- **重要：不要固定只问 3-4 个问题，复杂需求必须问 8-12 个！**

---

## 执行流程

### Phase 0: 模式选择（AI 推荐 + 用户决定）

**目标：** 根据用户的初始需求描述，AI 评估复杂度并推荐模式，但最终由用户选择。

**注意：** 如果用户的消息中已包含 `[模式:功能开发]`、`[模式:完整规划]`、`[模式:导入]` 等模式标记（由 Viewer 前端自动添加），则跳过模式选择，直接按指定模式进入对应流程。

**步骤 1：接收用户需求描述**

用户提供初始需求描述后，在内部进行复杂度评估（不展示给用户）：

| 分析维度 | 权重 | Feature Build | Full Planning |
|----------|------|---------------|---------------|
| 涉及文件数（预估） | 30% | 3-8个 | 8+个 |
| 是否有数据模型变更 | 25% | 可能有 | 一定有 |
| 是否需要新建模块/页面 | 20% | 可能 | 是 |
| 是否涉及多个系统层 | 15% | 2-3层 | 全栈 |
| 描述复杂度（字数/概念） | 10% | 50-200字 | 200+字 |

**步骤 2：使用 AskUserQuestion 呈现选择**

```json
{
  "questions": [
    {
      "question": "我分析了你的需求，推荐使用以下模式。请选择：",
      "header": "模式选择",
      "options": [
        { "label": "功能开发 (~10-15分钟) 推荐", "description": "适合新功能、新页面、多文件变更。流程：核心问答->任务规划->确认->自动执行" },
        { "label": "完整规划 (~30-45分钟)", "description": "适合架构级变更、新模块、复杂系统。流程：5层金字塔问答->富化规格->确认->自动执行" },
        { "label": "PRD 导入 (~15-20分钟)", "description": "你已有现成的需求文档，系统将分析→补充→转换为标准格式→拆解为开发任务" }
      ],
      "multiSelect": false
    }
  ]
}
```

注意：「推荐」标记应根据 AI 评估结果放在对应的选项上。

**步骤 3：根据选择进入不同流程**

- **功能开发** -> 进入 Phase 0.5 L0 方向探索 → Phase 1（跳过 L2、L3，只走 L1 + L4 + 确认）
- **完整规划** -> 进入 Phase 0.5 L0 方向探索 → Phase 1（完整 L1->L5 流程，即当前默认流程）
- **PRD 导入** -> 跳过 L0，进入 Phase T1-Transform（Transform 流程，见下文）

---

### Phase 0.5: L0 方向探索（功能开发 + 完整规划模式）

**目标：** 在进入 L1 核心问答之前，先建立对项目和需求方向的共识，避免后续问答走偏。通过 2-3 个 AskUserQuestion 完成方向探索。

**跳过条件：**
- PRD 导入模式 → 自动跳过
- 用户消息中包含 `[跳过探索]` 或明确说"不需要探索"/"直接开始" → 跳过
- 需求描述已非常具体且明确（如已包含技术方案、文件路径、组件名称等） → AI 判断可跳过，但需告知用户

**L0 输出：** L0 收集的信息将作为后续所有层级（L1-L5）的上下文基础。具体输出保存在 metadata 的 `l0Context` 中，供后续层级引用。

#### 步骤 1：项目上下文快速扫描

在发起 L0 提问前，先执行轻量项目扫描（不等同于 Phase 2.5 的完整代码库扫描）：

- 使用 Glob 检查 `package.json`、`tsconfig.json` 等项目文件是否存在
- 如果有 `package.json`，使用 Read 读取 dependencies 部分，识别技术栈
- 使用 Glob 扫描顶层目录结构（`*`、`src/*`），了解项目结构
- 将扫描结果内化到 L0 问题的选项中

#### 步骤 2：发起 L0 方向探索提问（2-3 个 AskUserQuestion）

**第 1 次 AskUserQuestion — 需求方向理解 + 实现方案选择（带架构预览）：**

根据用户的初始需求描述和项目扫描结果，提出 2-3 种需求理解方式和对应的实现方案。**使用 `markdown` 字段为每个方向提供 ASCII 架构预览**，用户选择不同方向时右侧会展示对应的架构图。

```json
{
  "questions": [
    {
      "question": "【L0: 方向探索】\n\n基于你的描述和项目现状，我有以下几种实现方向。\n选择方向查看右侧架构预览：",
      "header": "需求方向",
      "options": [
        {
          "label": "方向 A（推荐）",
          "description": "[一句话总结核心思路]",
          "markdown": "方向 A: [名称]\n\n实现思路: [简要技术方案]\n涉及范围: [预估文件/模块]\n\n┌─────────────────────────────┐\n│  [架构示意图]                │\n│                             │\n│  [模块A] ──▶ [模块B]        │\n│     │                      │\n│     └──▶ [模块C]            │\n└─────────────────────────────┘\n\n✅ 优势: [优势]\n⚠️ 劣势: [劣势]"
        },
        {
          "label": "方向 B",
          "description": "[一句话总结核心思路]",
          "markdown": "方向 B: [名称]\n\n实现思路: [简要技术方案]\n涉及范围: [预估文件/模块]\n\n┌─────────────────────────────┐\n│  [架构示意图]                │\n│                             │\n│  [不同的模块布局]            │\n│                             │\n└─────────────────────────────┘\n\n✅ 优势: [优势]\n⚠️ 劣势: [劣势]"
        },
        {
          "label": "方向 C",
          "description": "[一句话总结（如有）]",
          "markdown": "方向 C: [名称]\n\n实现思路: [简要技术方案]\n涉及范围: [预估文件/模块]\n\n┌─────────────────────────────┐\n│  [架构示意图]                │\n└─────────────────────────────┘\n\n✅ 优势: [优势]\n⚠️ 劣势: [劣势]"
        },
        {
          "label": "都不对，我来说明",
          "description": "以上理解都有偏差，我会补充说明"
        }
      ],
      "multiSelect": false
    }
  ],
  "metadata": {
    "source": "pyramidprd",
    "level": 0,
    "levelName": "L0: 方向探索",
    "progress": "1/6",
    "totalLevels": 6,
    "l0Step": "direction"
  }
}
```

**markdown 预览规则：**
- 每个方向的 `markdown` 必须包含：名称、实现思路、涉及范围、ASCII 架构示意图、优劣势
- ASCII 图应体现该方向的核心模块关系和数据流向（使用 `┌─┐│└─┘──▶` 等 box-drawing 字符）
- 图的复杂度根据方案而定：简单方案 3-5 行，复杂方案 8-15 行
- 「都不对」选项不需要 `markdown` 字段
- 「推荐」标记应根据 AI 评估结果放在最匹配的选项上
- 如果方向只有 2 个，去掉方向 C 选项

**第 2 次 AskUserQuestion — 范围确认（YAGNI）：**

根据用户选择的方向，明确"要做的"和"不做的"：

```json
{
  "questions": [
    {
      "question": "【L0: 范围确认】\n\n基于你选择的方向，我整理了范围边界：\n\n**✅ 要做的（本次范围）：**\n1. [核心功能 1]\n2. [核心功能 2]\n3. [核心功能 3]\n\n**❌ 不做的（YAGNI）：**\n1. [排除项 1 — 原因]\n2. [排除项 2 — 原因]\n3. [排除项 3 — 原因]\n\n这个范围是否准确？",
      "header": "范围确认",
      "options": [
        { "label": "范围准确", "description": "同意以上范围划分，继续深入" },
        { "label": "需要调整", "description": "有功能需要增减，我会说明" }
      ],
      "multiSelect": false
    }
  ],
  "metadata": {
    "source": "pyramidprd",
    "level": 0,
    "levelName": "L0: 方向探索",
    "progress": "1/6",
    "totalLevels": 6,
    "l0Step": "scope"
  }
}
```

**处理"需要调整"：** 如果用户选择需要调整，根据反馈重新生成范围确认（最多重试 1 次，避免循环）。

#### 步骤 3：生成 L0 上下文摘要

L0 完成后，生成简短上下文摘要，作为后续层级的输入：

```
L0 上下文摘要:
- 选定方向: [方向名称 + 一句话描述]
- 实现思路: [选定的技术方案概要]
- 范围边界: [要做] vs [不做]
- 项目现状: [技术栈] + [关键现有模块]
```

此摘要保存在 metadata 的 `l0Context` 字段中，后续 L1-L5 的 AskUserQuestion 都应在 metadata 中携带此上下文。

**L0 完成后，进入 Phase 1（功能开发/完整规划模式的 L1 核心识别）。**

---

### Phase 1: 接收需求描述并评估复杂度

用户会提供一句话需求描述，例如：
- `/botoolagent-pyramidprd 做一个用户登录功能`
- `/botoolagent-pyramidprd 添加数据导出功能`

**收到后：**
1. **快速评估复杂度**（内部判断，不输出给用户）
2. **确定问题数量策略**
3. **立即开始 L1 提问**

**模式影响问答流程：**
- **功能开发模式** -> 只走 L1 核心识别 + L4 边界确认 + L5 确认门控（跳过 L2 领域分支和 L3 细节深入）
- **完整规划模式** -> 完整 L1 -> L2 -> L3 -> L4 -> L5 流程（当前默认行为）

**复杂度决定问题深度：**
- 简单需求 -> 每层 3-4 个问题，快速完成
- 中等需求 -> 每层 5-7 个问题，适度深入
- 复杂需求 -> 每层 8-12 个问题，全面覆盖

---

### 方案卡交互协议（L1-L4 统一）

**L1-L4 每层问答从 N 个 AskUserQuestion 合并为 1 个方案卡。** 方案卡在 question 文本中列出所有问题和 AI 推荐，用户只需选择「全部接受」或输入修改指令。

#### 方案卡模板

```
【LX: 层级名 — AI 方案卡】

基于: [前序层级 + 代码扫描结果摘要]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

 Q1. [问题描述]
   A) [选项A描述]
   B) [选项B描述]  ← 匹配现有项目
   C) [选项C描述]
   → AI 选择: B

 Q2. [问题描述]
   A) [选项A描述]  ← 推荐
   B) [选项B描述]
   → AI 选择: A

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
要修改请在下方 Type something 中输入如 "Q3 换 B"
```

#### AskUserQuestion 结构（3 个固定选项）

```json
{
  "questions": [{
    "question": "【方案卡内容】\n\n━━━━━━\n要修改请在下方 Type something 中输入如 \"Q3 换 B\"",
    "header": "LX 层级名",
    "options": [
      { "label": "全部接受 (推荐)", "description": "按 AI 推荐方案继续" },
      { "label": "方向不对，重新生成", "description": "补充说明后 AI 重新出方案卡" },
      { "label": "↓ 请在下方 Type something 输入修改", "description": "如 'Q3 换 B'" }
    ],
    "multiSelect": false
  }],
  "metadata": {
    "source": "pyramidprd",
    "level": <层级号>,
    "levelName": "LX: 层级名",
    "proposalCard": true
  }
}
```

#### AI 推荐选择规则

**强制规则：每个 Q 必须有且仅有一个 AI 推荐（← 标记），无例外。**

| 优先级 | 依据来源 | 示例 |
|--------|---------|------|
| 1 | 代码库扫描 (codebase-scan.md) | 项目用 Prisma → 推荐 PostgreSQL + Prisma |
| 2 | L0 方向 + 前序层级回答 (journal) | 用户选"管理面板" → 推荐 DataTable |
| 3 | 行业最佳实践 | 无代码库 → 推荐当前主流方案 |
| 4 | 最安全/最简单 | 无法判断时 → 推荐最稳妥选项 |

#### 修改指令解析规则

| 用户输入 | 解析结果 |
|---------|---------|
| `Q3 换 B` | 第 3 题改为选项 B |
| `Q2 换 C, Q5 换 B` | 第 2 题改为 C，第 5 题改为 B |
| `第 3 个问题换成 B` | 同 Q3 换 B |
| `认证方式换成 Session` | 按关键词匹配到对应 Q，选项匹配到对应字母 |

**解析优先级**: 精确格式 `QN 换 X` → 关键词匹配 → 无法匹配则追问一次确认。

**回显确认规则（强制）**: 修改指令解析后，AI 必须先回显解析结果（"收到：Q3 改为 B(Session 认证)"），等用户确认后再执行。

#### 逃生口处理

- 用户选"方向不对，重新生成" → AI 追问补充说明 → 重新生成方案卡
- **最多重试 2 次**，仍不满意 → 切换为逐题模式（恢复传统 AskUserQuestion per question）

#### Journal 写入

每层方案卡确认后，立即将所有 Q/A 结果写入（追加） `$PROJECT_DIR/qa-journal.md` 对应章节。

---

### Phase 2: L1 核心识别（方案卡）

**目标：** 理解需求的本质和范围

**Read journal** → 获取 L0 上下文

**必问话题（4-7 题，根据复杂度决定）：**
1. **问题域** - 这个需求涉及哪些领域？
2. **目标用户** - 谁会使用这个功能？
3. **核心价值** - 解决什么痛点？
4. **规模预期** - MVP 还是完整功能？

根据复杂度追加 3 题（中等/复杂需求）：
5. **优先级** - 哪些功能是 P0 必做？
6. **数据源** - 数据从哪里来？
7. **交付形式** - 需要哪些页面/API？

**使用方案卡交互协议**发送 1 个 AskUserQuestion（header: "L1 核心识别"）。

**L1 完成后 → Write journal §L1：**
- 记录所有 Q/A 选择结果
- 确定激活哪些 L2 维度（frontend, backend, ux, architecture）
- **进入 S1 代码库扫描**（如果有代码库）→ R1 规范确认 → L2

---

### Phase 2.5: S1 代码库感知扫描（Explore Subagent）

**目标：** 扫描当前项目代码库，识别技术栈、架构模式、现有组件和数据模型。**三模式统一（含 Transform）。**

**触发条件：** L1 完成后自动判断是否有代码库。

#### 判断是否有代码库

使用 Glob 工具检查当前工作目录是否有项目文件：
- 检查 `package.json`、`tsconfig.json`、`Cargo.toml`、`go.mod`、`requirements.txt`、`pom.xml` 等
- 如果没有任何项目文件 → **跳过扫描**，标记 `codebaseScanned: false`，直接进入 R1
- 如果有项目文件 → **执行 Explore Subagent 扫描**

#### 使用 Task(Explore) 执行扫描

**将代码扫描委托给 Explore subagent，释放主对话上下文。**

```
Task(subagent_type="Explore", prompt="""
对当前项目执行全面代码库扫描，输出结构化 codebase-scan.md。

扫描维度：
1. 技术栈检测：package.json dependencies、框架、语言、构建工具
2. 目录结构：顶层目录、架构模式（monorepo/App Router 等）
3. 现有组件/路由/API：组件名称、路由路径、API 端点
4. 数据模型：schema.prisma、types.ts、SQL 建表语句
5. 数据库 Schema：表名、字段、约束、RLS 策略
6. UI 组件接口：interface.*Props 定义
7. API 签名：export GET/POST/PUT/DELETE
8. 业务逻辑：services/、lib/ 的 export 列表

输出格式（Markdown）：
# Codebase Scan Report
## 技术栈
## 目录结构
## 现有组件
## 现有路由
## 现有 API 端点
## 数据模型
## 数据库 Schema（SQL 表摘要）
## UI 组件接口
## 业务逻辑函数

将结果写入文件：$TASKS_DIR/<projectId>/codebase-scan.md

⚠️ 上下文保护 — 返回消息格式：
文件写入后，返回结构化摘要（禁止复述文件内容，主对话会通过 Read 获取完整文件）：
- 技术栈: [框架 + 语言 + DB，一行]
- 统计: [组件数/路由数/API数/表数]
- 关键发现: [架构模式、特殊依赖、值得注意的设计]
- 缺失信号: [未发现的维度，如"无 schema.prisma"、"无 API 路由"]
控制在 15 行以内。
""")
```

#### 扫描结果双重用途

1. **内化到后续问题中**：L2 问题预设技术栈、组件选项包含已有组件名称
2. **作为 PRD 内容数据源**：§ 2 当前状态、§ 4 数据设计、§ 5 UI 设计、§ 8 文件索引

#### 扫描完成后

- 读取 `codebase-scan.md` 摘要写入 journal §S1
- 提示用户：> "已识别项目技术栈：[概要]，将基于现有架构生成更精准的问题。"

#### 无代码库时的降级处理

如果判断没有代码库（新项目）：
- 标记 `codebaseScanned: false`
- 跳过扫描，直接进入 R1
- PRD § 2 当前状态将显示为"新项目，无现有代码库"

---

### Phase 2.6: R1 规范确认（S1 后自动执行，全模式共享）

**目标：** 扫描项目 `rules/` 目录中的规范文件，让用户确认哪些规范适用于本次开发，将结果写入 qa-journal.md。

**触发条件：** S1 代码扫描完成后自动执行（功能开发、完整规划、Transform 三种模式都执行）。

**步骤：**

1. 使用 Glob 检查 `rules/*.md` 或 `BotoolAgent/rules/*.md` 是否存在
2. **无 rules/ 目录** → 跳过 R1，在 journal 中记录 "R1: 无 rules/ 目录，跳过"
3. **有 rules/ 目录** → 读取每个 .md 文件的前 30 行，提取规范名称和核心要点
4. 使用 AskUserQuestion 展示发现的规范列表，让用户确认：

```json
{
  "questions": [
    {
      "question": "【R1: 规范确认】\n\n在项目中发现以下规范文件，请选择本次开发适用的规范：",
      "header": "规范确认",
      "options": [
        { "label": "rules/frontend.md — 前端代码规范", "description": "[从文件前 30 行提取的核心要点摘要]" },
        { "label": "rules/api.md — API 设计规范", "description": "[核心要点摘要]" },
        { "label": "rules/mobile.md — 移动端规范", "description": "[核心要点摘要]" }
      ],
      "multiSelect": true
    }
  ],
  "metadata": {
    "source": "pyramidprd",
    "level": 1,
    "levelName": "R1: 规范确认",
    "progress": "R1",
    "rulesDetected": true
  }
}
```

注意：上方 options 为示例格式，实际应根据项目中发现的 rules/*.md 文件动态生成。每个选项的 label 包含文件名和规范名称，description 包含从文件前 30 行提取的核心要点。`multiSelect: true` 允许用户同时选择多个适用规范。

5. 将确认结果写入 `$TASKS_DIR/<projectId>/qa-journal.md`：

```markdown
## R1 规范确认
- ✅ rules/frontend.md — 前端代码规范
- ✅ rules/api.md — API 设计规范
- ❌ rules/mobile.md — 移动端规范（用户排除）
```

**R1 完成后，继续进入后续流程（L2 或对应模式的下一阶段）。**

---

### Phase 3: L2 领域分支（方案卡）

**目标：** 按领域深入探索具体需求。**仅完整规划模式执行，功能开发跳过。**

**Read journal** → 获取 L0 + L1 + S1 + R1 上下文

**融合扫描结果的规则：**
- 技术栈选项中预设 codebase-scan.md 识别的技术栈（AI 推荐 ← 标记）
- 组件选项包含已有组件名称（如「复用现有 DataTable 组件 ← 匹配现有项目」）
- 如果 `codebaseScanned: false`，使用通用选项

**维度定义（根据 L1 激活的维度选题，5-12 题）：**

| 维度 | 话题 |
|------|------|
| frontend | 页面结构、核心组件、响应式、交互方式 |
| backend | API 类型、数据模型、认证方式、存储需求 |
| ux | 用户旅程、核心流程、错误处理、反馈机制 |
| architecture | 技术栈、模块划分、部署方式 |
| dataModel | 新建表？关键字段？表间关系？约束/枚举/软删除？ |
| uiStructure | 新页面数/路由？复用/新建组件？弹窗？布局？ |

**使用方案卡交互协议**发送 1 个 AskUserQuestion（header: "L2 领域分支"）。

**L2 完成后 → Write journal §L2** → 进入 L3

---

### Phase 4: L3 细节深入（方案卡）

**目标：** 根据 L2 答案，深入实现细节。**仅完整规划模式执行，功能开发跳过。**

**Read journal** → 获取 L0-L2 + S1 + R1 上下文

**动态话题（根据 L2 答案激活，5-12 题）：**

| 条件 | 话题 |
|------|------|
| 有表单 | 验证规则、错误提示方式、提交流程 |
| 有列表 | 分页方式、排序过滤、空状态 |
| 有 API | 错误处理、权限控制 |
| 有数据模型 | 模型关系、字段定义 |
| 有状态流转 | 状态列表、转换规则、不可逆操作、副作用 |
| 有业务规则 | 核心规则、删除级联、危险操作确认、边界条件 |
| 有组件交互 | 弹窗确认流程、下拉选项来源、拖拽/批量操作 |

**使用方案卡交互协议**发送 1 个 AskUserQuestion（header: "L3 细节深入"）。

**L3 完成后 → Write journal §L3** → 进入 L4

---

### Phase 5: L4 边界确认（方案卡）

**目标：** 确认范围边界，防止范围蔓延

**Read journal** → 获取 L0-L3 + S1 + R1 上下文

**必问话题（4-7 题）：**

| 话题 | 问题 |
|------|------|
| 集成点 | 需要修改哪些现有代码？ |
| 排除范围 | 哪些功能明确不做？ |
| 非功能需求 | 性能/安全要求？ |
| MVP 边界 | 哪些可以推迟？ |
| 文件命名约定 | API 路径模式？组件命名约定？目录结构？ |
| 现有代码修改范围 | 修改哪些文件？是否变更数据库？是否修改类型定义？ |

**使用方案卡交互协议**发送 1 个 AskUserQuestion（header: "L4 边界确认"）。

**L4 完成后 → Write journal §L4** → 进入 Phase 5.5 外部依赖扫描

---

### Phase 5.5: 外部依赖扫描（L4 完成后自动执行）

**目标：** 在进入 L5 前，扫描所有已收集的需求，识别开发前需要用户准备的外部依赖，写入 dev.json 的 `prerequisites` 字段，让 Lead Agent 能在开始 coding 前给用户预警。

**触发条件：** L4 完成后自动执行（功能开发 + 完整规划模式）。Transform 模式在 PRD 生成后执行。

#### 扫描规则

扫描 L0-L4 收集的全部需求描述，检测以下信号词：

| 信号关键词 | 识别为 prerequisite |
|-----------|-------------------|
| 支付、Stripe、微信支付、PayPal、收款 | `{ type: "api_key", name: "支付平台 API Key" }` |
| 邮件通知、短信、SendGrid、SMTP | `{ type: "service", name: "邮件/短信服务账号" }` |
| OAuth、GitHub 登录、Google 登录、微信登录 | `{ type: "oauth", name: "OAuth App 凭证" }` |
| 数据库 URL、PostgreSQL、MySQL、DATABASE_URL | `{ type: "env_var", name: "DATABASE_URL 连接字符串" }` |
| OpenAI、AI API、大模型、GPT、Claude API | `{ type: "api_key", name: "AI 服务 API Key" }` |
| 地图、高德、Google Maps、天气 API | `{ type: "api_key", name: "第三方地图/天气 API Key" }` |
| S3、OSS、云存储、对象存储 | `{ type: "credentials", name: "云存储访问凭证" }` |

**未检测到任何信号 → 跳过，直接进入 L5。**

**检测到 1 个或以上 → 一次 AskUserQuestion 展示：**

```json
{
  "questions": [
    {
      "question": "【依赖预检】检测到以下外部依赖，开发启动前需要准备好：\n\n[列出每项：类型 + 名称]\n\n你目前的准备状态？",
      "header": "外部依赖",
      "options": [
        { "label": "已全部准备好", "description": "API Key / 账号 / 环境变量均已就绪" },
        { "label": "部分准备好，继续规划", "description": "先完成 PRD，开发前补充剩余依赖" },
        { "label": "都没有，先规划", "description": "先生成 PRD，依赖后续处理" }
      ],
      "multiSelect": false
    }
  ]
}
```

**写入 prerequisites 字段规则：**
- 不管用户选哪个，检测到的依赖都写入 dev.json `prerequisites`
- "已全部准备好" → 各项 `resolved: true`
- 其他选项 → 各项 `resolved: false`
- Lead Agent 会在初始化时读取此字段，在 progress.txt 中给出预警提示

---

### Phase 5.8: Compact 检查点（L5 前自动触发）

**目标：** L5 确认门控是 context 消耗最重的阶段（2 轮 ASCII 可视化）。在进入 L5 前，给用户一个压缩对话的机会，防止 auto-compact 在 L5 中途触发导致上下文丢失。

**触发条件：** Phase 5.5 完成后、Phase 6 (L5) 开始前自动执行。

**前置检查：** 确认 qa-journal.md 已包含 L0-L4 + S1 + R1 所有层级的决策数据。如有缺失，先补写再继续。

**执行步骤：**

1. 使用 AskUserQuestion 询问用户：

```json
{
  "questions": [
    {
      "question": "即将进入 L5 确认门控（2 轮 ASCII 可视化，context 消耗较大）。建议先压缩对话释放空间。如何继续？",
      "header": "Context 检查",
      "options": [
        { "label": "先 compact 再继续（推荐）", "description": "运行 /compact 压缩对话历史，释放 context 空间后继续 L5" },
        { "label": "直接继续 L5", "description": "跳过压缩，直接进入确认门控（context 充足时选此项）" }
      ],
      "multiSelect": false
    }
  ]
}
```

2. **如果用户选择 "先 compact 再继续"：**
   - 输出以下提示（原文照抄）：

   ```
   ✅ 所有需求数据已保存到 qa-journal.md。

   👉 请在输入框中运行 /compact，完成后回复「继续」。

   compact 后我会从 qa-journal.md 恢复上下文，继续 L5 确认门控。
   ```

   - 等待用户回复「继续」或类似确认词
   - **恢复上下文：** Read qa-journal.md + codebase-scan.md（如存在），在内部重建 L0-L4 决策摘要
   - 继续进入 Phase 6 (L5)

3. **如果用户选择 "直接继续 L5"：**
   - 直接进入 Phase 6 (L5)

---

### Phase 6: L5 确认门控（ASCII 多维度可视化）

**目标：** L4 完成后，在生成 PRD 前，向用户展示 **ASCII 可视化的多维度确认摘要**，确保需求理解一致。

**触发条件：** L4 所有问题回答完毕后自动进入。

#### 按模式裁剪 L5 步骤

8 个维度分 **2 轮 Tabs** 展示，每轮 4 个 Tab，用户可左右切换快速审阅。每个 Tab 只聚焦 **一个维度**。

| 维度 | Tab | 功能开发 | 完整规划 |
|------|-----|---------|---------|
| 项目概述 | 第 1 轮 Tab 1 | 展示 | 展示 |
| 核心架构 | 第 1 轮 Tab 2 | 展示 | 展示 |
| 用户角色 | 第 1 轮 Tab 3 | 展示 | 展示 |
| 核心工作流 | 第 1 轮 Tab 4 | 展示 | 展示 |
| 数据模型 | 第 2 轮 Tab 1 | 跳过 | 展示 |
| 关键 UI | 第 2 轮 Tab 2 | 跳过 | 展示（仅有前端时） |
| 业务规则 | 第 2 轮 Tab 3 | 跳过 | 展示 |
| 总确认 | 第 2 轮 Tab 4 | 展示 | 展示 |

**功能开发模式：** 只展示第 1 轮（4 Tabs）+ 第 2 轮 Tab 4（总确认），跳过数据模型/关键 UI/业务规则。

**设计原则：**
- 每个 Tab 的 ASCII 可视化内容必须聚焦单一维度，禁止混合多个维度
- 使用 AskUserQuestion 的多问题能力（最多 4 个 questions），每个 question 作为一个 Tab
- 用户可以在 Tabs 之间左右切换，快速审阅所有维度，一次性提交确认

---

#### 第 1 轮：架构与角色确认（4 Tabs 同时展示）

**一次 AskUserQuestion 调用，包含 4 个 questions（= 4 个 Tabs）。** 用户可切换 Tab 逐个审阅。

**Tab 1 — 项目概述** ASCII 模板：
```
┌─────────────────────────────────────────┐
│  [项目名称] v[版本]                     │
│  [一句话定位描述]                        │
├─────────────────────────────────────────┤
│                                         │
│  背景: [为什么要做这个项目/功能]         │
│                                         │
│  目标:                                  │
│    1. [核心目标1]                        │
│    2. [核心目标2]                        │
│    3. [核心目标3]                        │
│                                         │
│  技术栈: [框架] + [语言] + [数据库]      │
│          + [状态管理] + [其他]           │
│                                         │
│  模式: [功能开发 / 完整规划 / PRD导入]    │
└─────────────────────────────────────────┘
```

**Tab 2 — 核心架构** ASCII 模板：
```
───────── 核心实体关系 ─────────

   [实体A]
      │
      ├──── 1:N ──── [实体B]
      │                  │
      │                  └── 1:N ──── [实体C]
      │
      └──── M:N ──── [实体D]

───────── 实体说明 ─────────
┌──────────────┬──────────────────────────┐
│ 实体         │ 职责                     │
├──────────────┼──────────────────────────┤
│ [实体A]      │ [一句话说明其核心职责]    │
│ [实体B]      │ [一句话说明其核心职责]    │
│ [实体C]      │ [一句话说明其核心职责]    │
│ [实体D]      │ [一句话说明其核心职责]    │
└──────────────┴──────────────────────────┘
```

**Tab 3 — 用户角色** ASCII 模板：
```
───────── 角色定义 ─────────

┌──────────────────┐     ┌──────────────────┐
│  [角色A]         │     │  [角色B]         │
│                  │     │                  │
│  权限:           │     │  权限:           │
│  - [权限1]       │     │  - [权限1]       │
│  - [权限2]       │     │                  │
│  - [权限3]       │     │  入口:           │
│                  │     │  [路由/页面]      │
│  入口:           │     └──────────────────┘
│  [路由/页面]      │
└──────────────────┘

───────── 权限矩阵 ─────────
┌──────────┬────────┬────────┬────────┐
│ 操作     │ 角色A  │ 角色B  │ 角色C  │
├──────────┼────────┼────────┼────────┤
│ [操作1]  │  [权限] │  [权限] │  [权限] │
│ [操作2]  │  [权限] │  [权限] │  [权限] │
│ [操作3]  │  [权限] │  [权限] │  [权限] │
└──────────┴────────┴────────┴────────┘
```

**Tab 4 — 核心工作流** ASCII 模板：
```
───────── 阶段流转 ─────────

Phase 1 ──▶ Phase 2 ──▶ Phase 3 ──▶ Phase 4
[名称]      [名称]      [名称]      [名称]
(P0)        (P0)        (P1)        (P2)

───────── 阶段详情 ─────────
┌─────────┬──────────────────┬──────┐
│ Phase   │ 内容             │ 优先级│
├─────────┼──────────────────┼──────┤
│ Phase 1 │ [一句话描述]      │ P0   │
│ Phase 2 │ [一句话描述]      │ P0   │
│ Phase 3 │ [一句话描述]      │ P1   │
│ Phase 4 │ [一句话描述]      │ P2   │
└─────────┴──────────────────┴──────┘

───────── 依赖关系 ─────────
Phase 1 → 全部（基础设施）
Phase 2 + 3 → Phase 4
Phase 3 可并行
```

**AskUserQuestion 调用（第 1 轮）：**
```json
{
  "questions": [
    {
      "question": "【L5 第 1 轮 — Tab 1/4】\n\n[项目概述 ASCII 内容]\n\n以上项目概述是否准确？",
      "header": "项目概述",
      "options": [
        { "label": "准确", "description": "项目定位、目标和技术栈描述正确" },
        { "label": "需要修改", "description": "有不准确的地方，我会说明" }
      ],
      "multiSelect": false
    },
    {
      "question": "【L5 第 1 轮 — Tab 2/4】\n\n[核心架构 ASCII 内容]\n\n以上核心架构是否准确？",
      "header": "核心架构",
      "options": [
        { "label": "准确", "description": "实体关系和职责描述正确" },
        { "label": "需要修改", "description": "有不准确的地方，我会说明" }
      ],
      "multiSelect": false
    },
    {
      "question": "【L5 第 1 轮 — Tab 3/4】\n\n[用户角色 ASCII 内容]\n\n以上用户角色和权限是否准确？",
      "header": "用户角色",
      "options": [
        { "label": "准确", "description": "角色划分和权限描述正确" },
        { "label": "需要修改", "description": "有不准确的地方，我会说明" }
      ],
      "multiSelect": false
    },
    {
      "question": "【L5 第 1 轮 — Tab 4/4】\n\n[核心工作流 ASCII 内容]\n\n以上工作流阶段和依赖关系是否准确？",
      "header": "核心工作流",
      "options": [
        { "label": "准确", "description": "阶段划分、优先级和依赖描述正确" },
        { "label": "需要修改", "description": "有不准确的地方，我会说明" }
      ],
      "multiSelect": false
    }
  ],
  "metadata": {
    "source": "pyramidprd",
    "level": 5,
    "levelName": "L5: 确认门控",
    "round": "1/2",
    "roundName": "架构与角色确认",
    "tabs": ["项目概述", "核心架构", "用户角色", "核心工作流"]
  }
}
```

**处理修改请求：** 如果任何 Tab 被选择了「需要修改」，用户会通过 "Other" 选项说明修改内容。根据反馈调整对应维度后，**仅重新展示需要修改的 Tab**（使用单独的 AskUserQuestion，questions 数量 = 需修改的 Tab 数量）。

**功能开发模式：** 第 1 轮全部展示（4 Tabs），与完整规划一致。

---

#### 第 2 轮：数据与实现确认（4 Tabs 同时展示）

**一次 AskUserQuestion 调用，包含 4 个 questions（= 4 个 Tabs）。**

**Tab 1 — 数据模型** ASCII 模板：
```
───────── 数据表 ─────────
┌──────────────┬──────────────────────┬───────────┐
│ 模型         │ 关键字段              │ 状态      │
├──────────────┼──────────────────────┼───────────┤
│ [table_a]    │ id, name, type, ...  │ 新建      │
│ [table_b]    │ id, a_id, value, ... │ 新建      │
│ [existing]   │ id, ...              │ 修改(+col)│
└──────────────┴──────────────────────┴───────────┘

───────── 表间关系 ─────────
[table_a] ──1:N──▶ [table_b]
[table_a] ──N:1──▶ [existing]

───────── 索引建议 ─────────
[table_b].a_id  → 外键索引
[table_a].type  → 查询索引
```

**Tab 2 — 关键 UI（仅有前端时）** ASCII 模板：

**每个关键页面/弹窗单独展示。** 如果页面较多，在 question 文本中依次排列所有页面的 ASCII 线框：

```
───────── 页面 1: [页面名] ─────────
┌─────────────────────────────────────────┐
│  [Header / Nav]                         │
│  ┌──────────┬──────────────────────┐   │
│  │ Sidebar  │ Main Content         │   │
│  │          │                      │   │
│  │ - Item1  │ ┌──────────────────┐ │   │
│  │ - Item2  │ │  Data Table      │ │   │
│  │ - Item3  │ │  or Form         │ │   │
│  │          │ └──────────────────┘ │   │
│  └──────────┴──────────────────────┘   │
└─────────────────────────────────────────┘

───────── 页面 2: [页面名] ─────────
┌─────────────────────────────────────────┐
│  [不同布局的页面]                        │
│  ...                                    │
└─────────────────────────────────────────┘

───────── 弹窗: [弹窗名] ─────────
┌─────────────────────────────────┐
│  [弹窗标题]                [x]  │
│  ─────────────────────────────  │
│  [表单字段 / 选项列表]          │
│                                 │
│              [取消]  [确认]      │
└─────────────────────────────────┘
```

**Tab 3 — 业务规则** ASCII 模板：
```
───────── 业务规则 ─────────
┌─────┬──────────────────────────┬──────────────┐
│ ID  │ 规则                     │ 影响范围     │
├─────┼──────────────────────────┼──────────────┤
│ BR1 │ [规则描述1]              │ Phase 1      │
│ BR2 │ [规则描述2]              │ Phase 2,3    │
│ BR3 │ [规则描述3]              │ Phase 3      │
└─────┴──────────────────────────┴──────────────┘

───────── 决策树: [场景名] ─────────
用户操作
├── 条件A?
│   ├── 是 → 执行动作X
│   └── 否 → 执行动作Y
└── 条件B?
    └── 是 → 弹窗警告 → 用户确认 → 执行
```

**Tab 4 — 总确认（开发计划 + 风险）** ASCII 模板：

**此 Tab 不重复前面已确认的内容**，只聚焦执行层面：

```
───────── 开发计划 ─────────
Phase 1 ──▶ Phase 2 ──▶ Phase 3
[名称]      [名称]      [名称]
DT数: N     DT数: M     DT数: K
(P0)        (P0)        (P1)

依赖: Phase 1 是 Phase 2/3 的前置

───────── 风险评估 ─────────
HIGH:   [风险项]
MEDIUM: [风险项]
LOW:    [风险项]

───────── 安全检查预告 ─────────
将为 DT-001、DT-003 自动注入 N 项安全验收标准

───────── 复杂度估计 ─────────
[简单/中等/复杂]，预计 N 个开发任务，分 M 个 Phase
```

**AskUserQuestion 调用（第 2 轮）：**
```json
{
  "questions": [
    {
      "question": "【L5 第 2 轮 — Tab 1/4】\n\n[数据模型 ASCII 内容]\n\n以上数据模型是否准确？",
      "header": "数据模型",
      "options": [
        { "label": "准确", "description": "数据表、字段和关系描述正确" },
        { "label": "需要修改", "description": "有不准确的地方，我会说明" }
      ],
      "multiSelect": false
    },
    {
      "question": "【L5 第 2 轮 — Tab 2/4】\n\n[关键 UI ASCII 内容]\n\n以上 UI 布局是否准确？",
      "header": "关键 UI",
      "options": [
        { "label": "准确", "description": "页面布局和交互流程描述正确" },
        { "label": "需要修改", "description": "有不准确的地方，我会说明" }
      ],
      "multiSelect": false
    },
    {
      "question": "【L5 第 2 轮 — Tab 3/4】\n\n[业务规则 ASCII 内容]\n\n以上业务规则是否准确？",
      "header": "业务规则",
      "options": [
        { "label": "准确", "description": "业务规则和决策逻辑描述正确" },
        { "label": "需要修改", "description": "有不准确的地方，我会说明" }
      ],
      "multiSelect": false
    },
    {
      "question": "【L5 第 2 轮 — Tab 4/4】\n\n[总确认 ASCII 内容]\n\n以上开发计划和风险评估是否准确？确认后将生成完整 PRD 文档。",
      "header": "总确认",
      "options": [
        { "label": "确认并生成 PRD", "description": "所有信息准确，请生成完整 PRD 文档" },
        { "label": "需要修改", "description": "部分信息不准确，需要调整" }
      ],
      "multiSelect": false
    }
  ],
  "metadata": {
    "source": "pyramidprd",
    "level": 5,
    "levelName": "L5: 确认门控",
    "round": "2/2",
    "roundName": "数据与实现确认",
    "tabs": ["数据模型", "关键 UI", "业务规则", "总确认"],
    "confirmationSummary": { ... }
  }
}
```

**功能开发模式：** 第 2 轮只展示 Tab 4（总确认），使用单独的 AskUserQuestion（1 个 question）。

**处理修改请求：** 同第 1 轮逻辑 — 仅重新展示需要修改的 Tab。

**选择「确认并生成 PRD」（第 2 轮 Tab 4）：** 进入 Phase 7 生成 PRD。

**选择「需要修改」：** 使用 AskUserQuestion 询问修改范围（同之前的逻辑：修改功能范围/技术方案/风险评估/移除安全项/返回重新提问）。

---

### Phase 7: G1/W1 PRD 生成（general-purpose Subagent 委托）

**L5 确认门控通过后，将 PRD 生成委托给 general-purpose Subagent，释放主对话上下文。**

**输出路径（per-project 子目录）：**
```bash
TASKS_DIR="$([ -d BotoolAgent/tasks ] && echo BotoolAgent/tasks || echo tasks)"
PROJECT_DIR="$TASKS_DIR/<projectId>"
mkdir -p "$PROJECT_DIR"
# PRD 写入: $PROJECT_DIR/prd.md
# (dev.json 和 registry 由 PRDing Ralph 管线中的 A2:prd2json 自动生成)
```

#### Subagent 委托调用

**⚠️ Transform 模式使用多 Subagent 分段生成（解决单 Subagent 32000 token 输出上限问题）。**
**功能开发/完整规划模式继续使用单 Subagent 生成。**

---

**路径 A: 功能开发/完整规划模式 — 单 Subagent 生成**

```
Task(
  subagent_type: "general-purpose",
  description: "生成 PRD 文档",
  prompt: """
你是 BotoolAgent PRD 生成器。根据以下输入生成完整的 PRD 文档。

## 输入

### Q&A Journal（需求决策记录）
<读取 $PROJECT_DIR/qa-journal.md 的全部内容并粘贴到此处>

### 代码库扫描报告
<读取 $PROJECT_DIR/codebase-scan.md 的全部内容并粘贴到此处（如不存在则写 "新项目，无现有代码库"）>

### 生成参数
- 模式: <功能开发 | 完整规划>
- projectId: <projectId>
- 输出路径: $PROJECT_DIR/prd.md

## 生成规则

<将下方「复杂度裁剪规则」「PRD 模板」「Dev Task 规则」全部嵌入 prompt>

## 安全检查自动注入

<将下方「Phase 7.5 安全检查自动注入」规则嵌入 prompt>

生成完成后，将 PRD 写入 $PROJECT_DIR/prd.md。

⚠️ 上下文保护 — 返回消息格式：
文件写入后，返回结构化摘要（禁止复述 PRD 内容，主对话会验证文件）：
- 生成统计: [总行数/DT 数量/Phase 数量/CREATE TABLE 数]
- 维度覆盖: [§1-§8 各维度是否生成，一行概要]
- 异常标记: [生成中跳过或降级的内容]
控制在 15 行以内。
"""
)
```

---

**路径 B: Transform 导入模式 — 3 个 Subagent 分段生成**

Transform 模式的 PRD 通常超过 2000 行，单个 Subagent 的输出 token 上限（32000）无法容纳。
必须拆分为 3 个并行 Subagent，每个负责生成 PRD 的一部分。

**步骤 B1: 启动 3 个 general-purpose Subagent（并行）**

```
# Subagent A: §1-§3（概述 + 当前状态 + 架构设计）
Task(
  subagent_type: "general-purpose",
  description: "Transform PRD §1-§3",
  prompt: """
你是 BotoolAgent PRD 生成器（分段模式 — 第 1/3 部分）。

## 核心原则：复制粘贴，不要重写
你的工作是「搬运 + 包装」，不是「理解后重写」。
读取源 PRD 内容后，直接复制粘贴到 BotoolAgent 格式的章节标题下。
**禁止用自己的话改写源 PRD 中的技术内容。**

## 任务
生成 BotoolAgent PRD 的 §1-§3 部分：
- § 1. 项目概述（背景/目标/指标）
- § 2. 当前状态（已有能力/缺口分析）
- § 3. 架构设计（核心概念/角色/工作流/状态机 — 含所有 ASCII 图）

## 操作指令
1. Read 源 PRD 中映射到 §1 的源章节 → §1.1 背景精简为 1-2 段，但**设计原则列表/核心原则表格必须逐条复制**
2. Read 源 PRD 中映射到 §2 的源章节 → 直接复制「已有能力」表格和缺口分析
3. Read 源 PRD 中映射到 §3 的所有源章节 → 逐个复制：
   - 技术栈表 → 逐行复制
   - 应用配置表 → 逐行复制
   - URL 路由设计表 → 逐行复制（含拆分前 vs 后对比）
   - 认证设计 → 逐段复制（含代码示例）
   - 所有 ASCII 图（架构图/流程图/状态机图/目录树）→ 逐字复制，不可重画
   - 状态机定义 → 逐字复制
   - 共享包目录树和使用示例 → 逐字复制

## 输入
### Q&A Journal
<读取 $PROJECT_DIR/qa-journal.md 全部内容>

### 代码库扫描报告
<读取 $PROJECT_DIR/codebase-scan.md（不存在则写"新项目"）>

### 源 PRD 原文
- 源 PRD 路径: $SOURCE_PRD_PATH
- 使用 Read 工具按映射表的行号范围分段读取每个源章节

### 源章节映射表
<粘贴 T2 完整映射表>

## 模板
<嵌入「PRD 模板」中 §1-§3 对应部分>

## 输出
写入: $PROJECT_DIR/prd-part-1.md
文件以 `# PRD: [功能名称]` 开头，包含 §1-§3 全部内容。

## 自检
写入完成后自检：
- §1 中的设计原则/核心原则列表条目数 ≥ 源 PRD（不允许精简条目）
- §3 中的 ASCII 图数量 ≥ 源 PRD 映射到 §3 的所有 ASCII 图数量
- §3 中的表格数量 ≥ 源 PRD（URL 路由表、技术栈表等）
不达标 → 重新 Read 源 PRD 补充复制。

⚠️ 上下文保护 — 返回结构化摘要（15 行以内）。
""")

# Subagent B: §4-§6（数据设计 + UI 设计 + 业务规则）
Task(
  subagent_type: "general-purpose",
  description: "Transform PRD §4-§6",
  prompt: """
你是 BotoolAgent PRD 生成器（分段模式 — 第 2/3 部分）。

## 核心原则：复制粘贴，不要重写
你的工作是「搬运 + 包装」，不是「理解后重写」。
读取源 PRD 内容后，直接复制粘贴到 BotoolAgent 格式的章节标题下。
**禁止用自己的话改写源 PRD 中的技术内容。**

## 任务
生成 BotoolAgent PRD 的 §4-§6 部分：
- § 4. 数据设计（SQL + ER 图 + 约束）
- § 5. UI 设计（线框图 + 组件 + 交互流程）
- § 6. 业务规则（规则表 + 决策树 + 流程图）

## 操作指令
1. Read 源 PRD 中映射到 §4 的源章节 → 逐个复制：
   - 每个 CREATE TABLE 语句 → 从 `CREATE TABLE` 到 `);` 逐字复制
   - ER 关系图 → 逐字复制
   - 约束表 → 逐行复制
   - 迁移映射表 → 逐行复制
2. Read 源 PRD 中映射到 §5 的源章节 → 逐个复制：
   - **每个 ASCII 线框图**（页面布局/弹窗/面板/对话框）→ 逐字复制，一个都不能少
   - 组件表 → 逐行复制
   - 交互流程图 → 逐字复制
   - 导入导出规格（格式映射表/安全规则/验证矩阵）→ 逐表复制
3. Read 源 PRD 中映射到 §6 的源章节 → 逐个复制：
   - **每个 ASCII 流程图**（翻译流程/审批流程等）→ 逐字复制
   - **每个规则表格** → 逐行复制
   - **每个 ASCII 线框图**（日志面板/确认弹窗等）→ 逐字复制
   - 决策树 → 逐字复制
   - 失败恢复规则/运行时策略 → 逐条复制

## 输入
### Q&A Journal
<读取 $PROJECT_DIR/qa-journal.md 全部内容>

### 源 PRD 原文
- 源 PRD 路径: $SOURCE_PRD_PATH
- 使用 Read 工具按映射表的行号范围分段读取每个源章节

### 源章节映射表
<粘贴 T2 完整映射表>

## 模板
<嵌入「PRD 模板」中 §4-§6 对应部分>

## 输出
写入: $PROJECT_DIR/prd-part-2.md
文件以 `## 4. 数据设计` 开头，包含 §4-§6 全部内容。

## 自检
写入完成后自检：
- §4: CREATE TABLE 数量 = 源 PRD 中的 100%
- §5: ASCII 线框图数量 ≥ 源 PRD 映射到 §5 的所有线框图（含弹窗/面板/对话框）
- §6: ASCII 流程图数量 ≥ 源 PRD 映射到 §6 的所有流程图
- §6: 规则表格行数 ≥ 源 PRD 的 90%
不达标 → 重新 Read 源 PRD 补充复制。

⚠️ 上下文保护 — 返回结构化摘要（15 行以内）。
""")

# Subagent C: §7-§8 + §9+（开发计划 + 附录 + 扩展章节）
Task(
  subagent_type: "general-purpose",
  description: "Transform PRD §7-§9+",
  prompt: """
你是 BotoolAgent PRD 生成器（分段模式 — 第 3/3 部分）。

## 核心原则：复制粘贴，不要重写
你的工作是「搬运 + 包装」，不是「理解后重写」。
§7 开发计划使用 T5 DT 分解结果（唯一允许重写的维度）。
§8 附录和 §9+ 扩展章节的内容必须从源 PRD 直接复制粘贴。

## 任务
生成 BotoolAgent PRD 的 §7-§8 + §9+ 部分：
- § 7. 开发计划（T5 DT 分解结果 + Phase 依赖图）
- § 8. 附录（文件索引 + 风险 + 测试 + 非目标 + 安全 + 技术实现代码 + API 归属分析）
- § 9+ 扩展章节（源 PRD 独立技术章节原文搬运）

## 操作指令
1. §7: 使用 T5 DT 分解的输出（从 qa-journal 中获取），但 Phase 依赖图从源 PRD 复制
2. Read 源 PRD 中映射到 §8 的源章节 → 逐个复制：
   - 代码文件索引表 → 逐行复制
   - 技术实现代码示例 → 每个代码块逐字复制
   - API 归属分析表 → 逐行复制
   - 清理变更清单 → 逐行复制
   - 新增：风险/测试/非目标/安全检查项（基于源 PRD 内容生成）
3. Read 源 PRD 中标记为 §9+ 的每个源章节 → **整章原文复制**：
   - 包括所有 ASCII 图、代码示例、表格、列表
   - 仅添加来源标注（`来源: 源 PRD §X`），不修改任何内容

## 输入
### Q&A Journal
<读取 $PROJECT_DIR/qa-journal.md 全部内容>

### 源 PRD 原文
- 源 PRD 路径: $SOURCE_PRD_PATH
- 使用 Read 工具按映射表的行号范围分段读取每个源章节

### 源章节映射表
<粘贴 T2 完整映射表>

## 模板
<嵌入「PRD 模板」中 §7-§8 + §9+ 对应部分>

## 安全检查自动注入
<嵌入「Phase 7.5 安全检查自动注入」规则>

## 输出
写入: $PROJECT_DIR/prd-part-3.md
文件以 `## 7. 开发计划` 开头，包含 §7-§8 + §9+ 全部内容。

## 自检
- §8: 技术实现代码块数量 = 源 PRD 附录中的代码块数量
- §9+: 每个 §9+ 章节存在且行数 ≥ 源章节行数的 90%
不达标 → 重新 Read 源 PRD 补充复制。

⚠️ 上下文保护 — 返回结构化摘要（15 行以内）。
""")
```

**步骤 B2: 主对话合并分段文件**

3 个 Subagent 完成后，主对话合并分段文件为最终 PRD：

```bash
# 验证 3 个分段文件存在且非空
for f in prd-part-1.md prd-part-2.md prd-part-3.md; do
  [ -s "$PROJECT_DIR/$f" ] || echo "❌ 缺失: $f"
done

# 合并为最终 prd.md
cat "$PROJECT_DIR/prd-part-1.md" "$PROJECT_DIR/prd-part-2.md" "$PROJECT_DIR/prd-part-3.md" > "$PROJECT_DIR/prd.md"

# 清理分段文件
rm -f "$PROJECT_DIR/prd-part-1.md" "$PROJECT_DIR/prd-part-2.md" "$PROJECT_DIR/prd-part-3.md"
```

**合并后校验（不可跳过）：**
1. 验证 §1-§8 + §9+ 各章节标题存在（`grep -c '^## [0-9]'`）
2. 检查章节边界无重复内容（part-1 和 part-2 的交接处）
3. 如发现分段间 DT 编号冲突 → 按 Phase 顺序重新编号

---

**Subagent 输入构造规则：**
1. 读取 `$PROJECT_DIR/qa-journal.md` 全部内容作为需求决策上下文
2. 读取 `$PROJECT_DIR/codebase-scan.md` 全部内容作为技术上下文（不存在则标记"新项目"）
3. 根据 journal 中标注的模式选择路径：功能开发/完整规划 → 路径 A，Transform → 路径 B
4. 将下方所有模板规则嵌入 Subagent prompt（模板是 Subagent 的生成指令）
5. Transform 模式时，将 SOURCE_PRD_PATH 和源章节映射表传入每个 Subagent prompt

**Subagent 完成后：**
1. 验证 `$PROJECT_DIR/prd.md` 已写入且非空
2. 如果写入失败 → 报错并提供手动恢复指令
3. 继续进入 PRDing Ralph 编排器（A1 审查 + A2 转换）

#### 复杂度裁剪规则

| PRD 节 | 功能开发 | 完整规划 | Transform 导入 |
|--------|---------|---------|---------------|
| § 1. 项目概述 | 1 段 | 完整（背景/目标/指标） | 完整（与完整规划一致） |
| § 2. 当前状态 | 简要表格 | 完整（含 ASCII 缺口分析） | 完整（与完整规划一致） |
| § 3. 架构设计 | 概要（1 个 ASCII） | 完整（多 ASCII：概念/角色/工作流/状态机） | 完整（与完整规划一致） |
| § 4. 数据设计 | Schema 表格 | 完整（SQL CREATE + ER 图 + 约束） | 完整（与完整规划一致） |
| § 5. UI 设计 | 组件清单表格 | 完整（ASCII 布局 + 弹窗 + Props 接口） | 完整（与完整规划一致） |
| § 6. 业务规则 | 简要表格 | 完整（分领域规则表 + 决策树 ASCII） | 完整（与完整规划一致） |
| § 7. 开发计划 | Phase 列表 + DT | 完整（Phase 依赖图 + DT 含文件路径） | 完整（与完整规划一致） |
| § 8. 附录 | 文件索引 | 完整（文件索引 + 风险 + 测试 + 非目标 + 安全） | 完整（与完整规划一致） |
| § 9+ 扩展 | N/A | N/A | 动态（源 PRD 中映射到 §9+ 的独立技术章节原文保留） |

#### PRD 模板（完整规划模式）

```markdown
# PRD: [功能名称]

## 1. 项目概述

### 1.1 背景与动机
[基于 L1 答案描述背景和要解决的问题]

### 1.2 核心目标
- [目标 1：具体可衡量]
- [目标 2：具体可衡量]

### 1.3 成功指标
- [指标 1]
- [指标 2]

## 2. 当前状态

### 2.1 已有能力

| 模块 | 状态 | 说明 |
|------|------|------|
| [模块名] | ✅ 已实现 | [描述] |
| [模块名] | ⚠️ 部分实现 | [描述 + 缺失部分] |
| [模块名] | ❌ 未实现 | [描述] |

### 2.2 缺口分析

[基于代码库扫描，描述代码存在但功能不可用的部分，或完全缺失的部分]

## 3. 架构设计

### 3.1 核心概念

```
[ASCII 核心概念关系图 — 展示主要实体及其关系]
```

### 3.2 用户角色

```
[ASCII 角色权限图 — 展示不同角色的权限和可访问路由]
```

### 3.3 核心工作流

```
[ASCII 多 Phase 流程图 — 展示用户操作的完整步骤]
```

### 3.4 状态机

```
[ASCII 状态转换图 — 如有状态流转需求（如 draft → published）]
```

## 4. 数据设计

### 4.1 数据模型概览

| 模型 | 用途 | 关键字段 | 状态 |
|------|------|---------|------|
| [表名] | [用途] | [字段列表] | 新建/修改/已有 |

### 4.2 Schema 定义

```sql
-- [表名]: [用途]
CREATE TABLE [表名] (
  id            SERIAL PRIMARY KEY,
  [字段名]      [类型] [约束],  -- [说明]
  ...
  created_at    TIMESTAMPTZ DEFAULT NOW()
);
```

### 4.3 模型关系

```
[ASCII ER 图 — 展示表之间的关系]
```

### 4.4 约束与规则

| 约束 | 说明 |
|------|------|
| [约束名/索引] | [描述] |

## 5. UI 设计

### 5.1 页面清单

| 页面 | 路由 | 说明 | 状态 |
|------|------|------|------|
| [页面名] | `/path/to/page` | [描述] | 新建/已有 |

### 5.2 组件清单

| 组件 | Props 接口 | 复用位置 | 状态 |
|------|-----------|---------|------|
| [组件名] | `{ prop1: type, prop2: type }` | [页面列表] | 新建/已有/提取 |

### 5.3 关键页面布局

```
[ASCII 页面布局 — 展示核心页面的组件排列]
```

### 5.4 关键弹窗/交互

```
[ASCII 弹窗布局 — 展示核心弹窗的字段和按钮]
```

## 6. 业务规则

### 6.1 [领域名] 规则

| ID | 规则 | 说明 | 影响任务 |
|----|------|------|---------|
| BR-001 | [规则名] | [描述] | DT-XXX |

### 6.2 决策树

```
[ASCII 决策树 — 展示复杂业务逻辑的分支判断]
```

## 7. 开发计划

### 7.0 Phase 依赖图

```
Phase 1 ──▶ Phase 2 ──▶ Phase 3
[名称]     [名称]     [名称]
(P0)       (P0)       (P1)

依赖关系:
Phase 1 是所有后续 Phase 的前置
Phase 2, Phase 3 可并行
```

### 7.1 Phase 1: [名称] (P0)

> **前置**: 无
> **产出**: [具体产出描述]
> **对应设计**: Section 3.3, 4.2

- [ ] DT-001: [任务描述] (`API: /api/xxx`, `文件: src/xxx`)
- [ ] DT-002: [任务描述] (`组件: <Xxx>`, `文件: src/components/xxx`)
- [ ] DT-003: [任务描述]

### 7.2 Phase 2: [名称] (P1)

> **前置**: Phase 1
> **产出**: [具体产出描述]
> **对应设计**: Section 5.3, 5.4

- [ ] DT-004: [任务描述]
- [ ] DT-005: [任务描述]

[... 更多 Phase ...]

## 8. 附录

### A. 代码文件索引

| 文件路径 | 状态 | Phase | 任务 |
|---------|------|-------|------|
| `src/components/xxx.tsx` | 待开发 | Phase 2 | DT-004 |
| `src/api/xxx/route.ts` | 待开发 | Phase 1 | DT-001 |
| `src/lib/auth.ts` | ✅ 已有 | - | - |

### B. 风险与缓解措施

#### HIGH
- **[风险标题]**: [描述] → **缓解**: [方案]

#### MEDIUM
- **[风险标题]**: [描述] → **缓解**: [方案]

#### LOW
- **[风险标题]**: [描述] → **缓解**: [方案]

### C. 测试策略

#### 单元测试
- [测试场景]

#### 集成测试
- [测试场景]

#### E2E 测试
- [测试场景]

### D. 非目标 (Out of Scope)
- [明确不包含的功能，从 L4 答案提取]

### E. 安全检查项
[由安全关键词自动注入生成，详见 Phase 7.5]

## 9+ 源 PRD 扩展章节（仅 Transform 模式生成）

> 以下章节来自源 PRD 中无法自然映射到 §1-§8 的独立技术内容。
> 内容原文完整保留，章节编号从 9 开始递增。

### 9. [源章节标题]（来源: 源 PRD §X）
[源章节原文完整复制，包括所有代码、表格、ASCII 图]

### 10. [源章节标题]（来源: 源 PRD §Y）
[同上]

（根据源 PRD 实际章节数动态生成，可能为 0-N 个扩展章节）
```

#### PRD 模板（功能开发模式）

功能开发模式生成简化版 PRD，跳过 § 2/6，简化 § 3-5：

```markdown
# PRD: [功能名称]

## 1. 项目概述
[1 段描述]

## 3. 架构设计（概要）
[1 个 ASCII 工作流图]

## 4. 数据设计（概要）
| 模型 | 用途 | 关键字段 | 状态 |
[Schema 表格，不含完整 SQL]

## 5. UI 设计（概要）
| 组件 | Props | 状态 |
[组件清单表格，不含 ASCII 布局]

## 7. 开发计划
[Phase 列表 + 完整 DT 清单]

## 8. 附录
### A. 代码文件索引
### B. 风险与缓解措施
### D. 非目标
```

#### Dev Task 规则（不变）

- 每个任务要小而具体，能在一次迭代中完成
- 验收标准必须可验证
- 每个任务都要包含 "Typecheck passes"
- UI 任务要包含 "Verify in browser"
- **NEW：每个 DT 必须标注涉及的 API 路径、组件名或文件路径**
- **NEW：每个 Phase 必须标注前置依赖和对应的设计 Section**

---

### Phase 7.5: 安全检查自动注入（不变）

**在 Phase 7 生成所有 Dev Tasks 后、将 PRD 写入文件之前，执行以下安全扫描和自动注入。**

#### 扫描逻辑

逐个扫描每个 DT 的 title 和 description 文本，如果匹配以下关键词（不区分大小写），自动在该 DT 的 Acceptance Criteria 末尾（在 "Typecheck passes" 之前）追加对应的安全检查项：

| 触发关键词 | 自动追加的 Acceptance Criteria |
|------------|-------------------------------|
| 登录/认证/auth/密码/password/login | `- [ ] [安全] 密码使用 bcrypt/argon2 加密`<br>`- [ ] [安全] 使用 httpOnly cookies`<br>`- [ ] [安全] 登录接口设置速率限制` |
| 支付/payment/金额/price/checkout | `- [ ] [安全] 金额使用整数（分）存储避免浮点误差`<br>`- [ ] [安全] 支付接口验证签名`<br>`- [ ] [安全] CSRF 保护` |
| 用户输入/表单/form/input | `- [ ] [安全] 输入使用 schema 验证（如 zod）`<br>`- [ ] [安全] XSS 防护`<br>`- [ ] [安全] 字符串长度限制` |
| API/接口/endpoint/路由 | `- [ ] [安全] 使用参数化查询防止 SQL 注入`<br>`- [ ] [安全] 错误响应不泄露内部信息`<br>`- [ ] [安全] 添加权限检查` |
| 文件上传/upload/file | `- [ ] [安全] 文件类型白名单校验`<br>`- [ ] [安全] 文件大小限制`<br>`- [ ] [安全] 存储路径不可由用户控制` |
| 数据库/database/SQL/migration | `- [ ] [安全] 使用参数化查询`<br>`- [ ] [安全] 敏感字段加密存储`<br>`- [ ] [安全] 迁移脚本使用 IF NOT EXISTS` |

#### 注入规则

1. **`[安全]` 前缀**：所有注入的安全项必须以 `[安全]` 前缀标记
2. **多类别匹配**：一个 DT 可以匹配多个关键词类别，所有匹配类别的安全项都追加（去重）
3. **无匹配不注入**：不涉及安全关键词的 DT 不添加任何安全项
4. **Feature Build / Full Planning 模式**：所有六类关键词均触发注入

#### 安全项在 PRD 中的位置

- 注入到对应 DT 的验收标准中（§ 7 开发计划下的每个 DT）
- 同时汇总到 § 8.E 安全检查项附录中

---

## Transform Mode: PRD 导入流程

**适用场景：** 用户已有现成的 PRD/需求文档，需要转换为 BotoolAgent 标准格式（§ 1-8）并拆解为合格的开发任务 (DT)。

**核心原则：**
- 用户的 PRD 只是输入材料。BotoolAgent 始终需要自己格式的 PRD，包含正确粒度的 DT 分解。
- **生成的 PRD 只能比源 PRD 更全面，绝不能更少。** 源 PRD 中的所有设计细节（SQL Schema、代码示例、状态机定义、ASCII 图、业务规则）必须充分摘录到生成的 PRD 中，确保 Coding Agent 仅凭生成的 PRD 就能完成所有任务，无需回读源文件。
- 唯一可以省略的内容：版本更新日志 (Changelog)、会议纪要、与实现无关的背景叙述。

**触发条件：** 用户消息中包含 `[模式:导入]` 时进入 Transform 流程。

```
Phase T1 ──→ S1 ──→ R1 ──→ T2 ──→ T2.5 ──→ T3 ──→ T4 ──→ T5 ──→ T6 ──→ 5.8 ──→ L5确认 ──→ 生成PRD ──→ Phase 5.5
获取文件    代码扫描  规范确认  结构发现  完整性校验  覆盖评分  针对问答  DT分解   收敛门控  Compact  确认门控  输出PRD    外部依赖
            (复用)   (复用)   (Grep)   (必执行)   (打分)   (0-2轮)  (算法)   (复用)  检查点   (复用)              (复用)
```

**Transform 模式新增步骤说明：**

- **T1 → S1（代码扫描）：** T1 获取源文件后，执行 S1 代码库感知扫描（复用 Phase 2.5 的逻辑）。扫描当前项目的技术栈、目录结构、已有组件和数据模型，为后续 T2 结构发现和 PRD 生成提供代码库上下文。
- **S1 → R1（规范确认）：** S1 完成后执行 R1 规范确认（复用 Phase 2.6 的逻辑）。扫描 `rules/` 目录，让用户确认适用规范，结果写入 qa-journal.md。
- **生成PRD → Phase 5.5（外部依赖扫描）：** PRD 生成后执行 Phase 5.5 外部依赖扫描（复用已有的 Phase 5.5 逻辑）。扫描生成 PRD 中的外部依赖信号，写入 dev.json 的 `prerequisites` 字段。

---

### Phase T1: 源文件获取

**目标：** 验证并读取用户的源 PRD 文件。

1. 从用户消息中提取文件路径（`[模式:导入]` 后面的部分）
2. 用 Read 工具验证文件存在
3. **Transform 模式统一预扫描**（不限文件大小，Transform 模式始终执行）：
   3a. Grep 所有 `CREATE TABLE` 语句 → 列出表名，建立「必须保留表清单」，记入工作笔记
   3b. Grep `parent_id`、`source_type`、`REFERENCES`、`CHECK` 等关键字 → 建立「关键字段清单」
   3c. 统计结构性内容数量（CREATE TABLE 总数、ASCII 图块数、规则表行数），作为 T7 自检基准
   3d. **开发计划章节预扫描**（新增，不可跳过）：
       - Grep `^#{1,4}` 提取所有标题及行号，识别哪个顶层章节对应"开发计划"
         关键词：`开发|Phase|阶段|计划|里程碑|Sprint|任务清单|Roadmap`
         （源 PRD 的章节编号可能是 §7、§9、§10 等，不一定是 §7）
       - 识别该开发计划章节下所有子 Phase 标题（如 `### 9.1`、`## Phase 2`）
         → 建立「必须保留Phase清单」：每个 Phase 的标题 + 起止行号，记入工作笔记
       - Grep `^- \[.\]` 或 `^- \[ \]` 统计开发计划章节内的任务条目总数
         → 记入工作笔记作为 T2.5 校验基准（`任务条目基准: N 条`）
   3e. **源章节清单建立**（不可跳过，与 3a-3d 同时执行）：
       - 使用 Grep `^## ` 提取所有二级标题（顶层章节）及行号 → 建立「源章节清单」
         格式（记入工作笔记）：
           源章节清单:
             [1] §1 产品概述        行 10  - 行 450  (440行)
             [2] §2 数据库设计      行 451 - 行 900  (450行)
             ...
             [N] §X 变更记录       → ⏭️ 跳过 (Changelog)
       - 统计「需处理源章节总数」（排除 Changelog/会议纪要/项目管理后的数量）
       - 记入工作笔记：`源章节总数: N 个（需处理）`
       - ⚠️ 此清单是 T2.5 步骤 D 的校验基准，不得缺项
   3f. **实体预扫描**（Transform 模式不可跳过）：
       - Grep `(GET|POST|PUT|DELETE|PATCH)\s+/api/` → 建立「API 路由基准清单」
       - Grep `interface\s+\w+|type\s+\w+\s*=` → 建立「TypeScript 接口基准清单」
       - Grep `<[A-Z][a-zA-Z]+[>\s/]` → 建立「组件名基准清单」
       - 统计 ASCII 图块数（代码块内含 `┌│└─▶` 字符的块）→ 记入「ASCII 图块基准数」
       - 以上合并为「实体基准清单」，记入工作笔记

4. 在 metadata 中设置 `transformPhase: 'source-input'`、`sourcePrdPath: '<路径>'`
   4a. 将源文件路径写入 `$TASKS_DIR/<projectId>/SOURCE_PRD.ref`
       **路径安全校验（不可跳过）：**
       - 使用 realpath 归一化路径: `SAFE_PATH=$(realpath "$SOURCE_PRD_PATH")`
       - 拒绝包含 `..` 的路径（路径穿越）
       - 拒绝符号链接指向项目目录外的文件
       - 校验失败 → 报错退出，不继续执行
       （供 prd2json 阶段的完整性比对读取）
5. **Ti 备份（不可跳过）：**
   - 将源 PRD 文件备份为 `$PROJECT_DIR/prd_original.md`
   - 命令: `cp "$SOURCE_PRD_PATH" "$PROJECT_DIR/prd_original.md"`
   - 此备份用于后续 Tf 字段级比对的基准文件
   - 备份成功后在 metadata 中记录: `originalBackup: true`
6. 告知用户："正在分析您的 PRD 文档..."

---

### Phase T1.5: 大文件阈值路由

**目标：** 根据源 PRD 行数选择最优处理策略，防止大文件导致上下文溢出。

```bash
SOURCE_LINES=$(wc -l < "$SOURCE_PRD_PATH")
echo "源 PRD 行数: $SOURCE_LINES"
```

**三档路由：**

| 行数范围 | 策略代号 | 处理方式 | 说明 |
|---------|---------|---------|------|
| < 2000 | **Standard** | Phase T2 当前流程 | 主对话直接读取，无需拆分 |
| 2000-5000 | **C2** | 单源多遍抽取 | 4 个 Explore Subagent 按维度并行提取 |
| > 5000 | **C1** | Master Context + Phase Bundle | 两遍提取 + 并行 Subagent 处理 |

**路由逻辑：**
```
if SOURCE_LINES < 2000:
  → 进入 Phase T2（Standard 模式，当前流程不变）
elif SOURCE_LINES >= 2000 and SOURCE_LINES <= 5000:
  → 进入 Phase T2-C2（单源多遍抽取）
else:  # > 5000
  → 进入 Phase T2-C1（Master Context + Phase Bundle）
```

告知用户当前策略：
- Standard: "源文件 {N} 行，使用标准流程处理。"
- C2: "源文件 {N} 行（中型），使用 C2 多维度并行提取。"
- C1: "源文件 {N} 行（大型），使用 C1 Master Context + Phase Bundle 分包处理。"

---

### Phase T2-C2: 单源多遍抽取（2000-5000 行）

**目标：** 将源 PRD 的 4 个维度并行提取到独立文件，避免单次读取超出上下文。

#### 步骤 1: 按源章节顺序启动 4 个 Explore Subagent（并行）

```
# 按 T1「源章节清单」顺序均匀分配给 4 个 Subagent
# 例如源 PRD 有 12 个章节 → 每个 Subagent 负责 3 个章节
# 分配方式: 按清单顺序均分（Subagent 1: 章节 1-3, Subagent 2: 章节 4-6, ...）

Task(subagent_type="Explore", description="C2:源章节Part1",
  prompt="读取源 PRD 文件 $SOURCE_PRD_PATH，**完整提取**以下源章节的全部内容：
    [源章节 1 标题] (行 X1-Y1)
    [源章节 2 标题] (行 X2-Y2)
    [源章节 3 标题] (行 X3-Y3)

    **完整提取，不做筛选**：每个章节的全部内容（包括 SQL、代码、ASCII 图、表格）必须原文保留。
    使用 Read 工具的 offset/limit 参数按行号范围读取每个章节。

    输出到: $PROJECT_DIR/c2-chapters-part-1.md
    每个章节以 `# 源章节: [章节标题] (行 X-Y)` 为分隔。

    ⚠️ 上下文保护 — 返回消息格式：
    文件写入后，返回结构化摘要（禁止复述文件内容，主对话会通过 Read 获取完整文件）：
    - 章节清单: [每章节标题 + 行数]
    - 关键内容: [CREATE TABLE 数/ASCII 图数/规则表数]
    - 完整性自检: [每章节源行数 vs 提取行数]
    控制在 15 行以内。")

Task(subagent_type="Explore", description="C2:源章节Part2",
  prompt="...同上结构，负责源章节 4-6...")

Task(subagent_type="Explore", description="C2:源章节Part3",
  prompt="...同上结构，负责源章节 7-9...")

Task(subagent_type="Explore", description="C2:源章节Part4",
  prompt="...同上结构，负责源章节 10-12...")
```

#### 步骤 2: 主对话合并 + 映射

4 个 Subagent 完成后，主对话读取 4 个提取文件：
```
Read $PROJECT_DIR/c2-chapters-part-1.md
Read $PROJECT_DIR/c2-chapters-part-2.md
Read $PROJECT_DIR/c2-chapters-part-3.md
Read $PROJECT_DIR/c2-chapters-part-4.md
```

合并后，使用 T2 Standard 的映射逻辑（含 §9+ 路径）将内容分配到目标维度：
- 按关键词优先映射表逐章节映射到 §1-§8
- 无法归入 §1-§8 的独立技术规范 → 映射到 §9+ 扩展
- 建立完整「源章节映射表」（含 §9+ 标记），记入工作笔记

合并后的内容用于：
- T3 覆盖度评分
- 后续 Tq 方案卡补充

**C2 完成后 → 进入 Phase T2.5（完整性校验）→ T3 → Tq → T5 → L5 → G1/W1**

---

### Phase T2-C1: Master Context + Phase Bundle（> 5000 行）

**目标：** 将超大 PRD 分解为可管理的分包，每个分包自包含 master context + 单 Phase 内容。

#### 步骤 1: Master Context 提取

使用 Explore Subagent 从源 PRD 提取全局上下文（~500 行）：

```
Task(subagent_type="Explore", description="提取 master-context",
  prompt="""
读取源 PRD 文件 $SOURCE_PRD_PATH，提取全局上下文并输出到 $PROJECT_DIR/master-context.md。

提取内容（~500 行，必须完整保留）:
1. 项目概述摘要（压缩为 10-20 行）
2. 全部 CREATE TABLE 语句（完整保留每个字段、约束、注释，不可省略）
3. 架构设计关键部分（状态机定义、角色权限矩阵）
4. 全局业务规则（跨 Phase 的约束规则）
5. 技术栈声明（框架、语言、数据库、依赖）

输出格式:
# Master Context — [项目名]
## 项目概述
[摘要]
## 数据库 Schema（完整）
[所有 CREATE TABLE]
## 架构设计
[状态机、权限]
## 全局规则
[跨 Phase 规则]
## 技术栈
[声明]

输出到: $PROJECT_DIR/master-context.md

⚠️ 上下文保护 — 返回消息格式：
文件写入后，返回结构化摘要（禁止复述文件内容，主对话会通过 Read 获取完整文件）：
- 统计: [表数/字段总数/规则条数/状态机数]
- 关键发现: [核心架构决策、跨模块依赖等]
- 完整性自检: [CREATE TABLE 数量 vs 源 PRD 总数，是否有遗漏]
控制在 10 行以内。
""")
```

验证 master-context.md:
- 文件存在且非空
- 包含所有 CREATE TABLE（`grep -c 'CREATE TABLE' master-context.md` ≥ T1「必须保留表清单」的 80%）
- 行数在 300-800 行范围内（过短说明提取不充分，过长说明压缩不够）

#### 步骤 2: Phase Bundle 分包

根据 T1「必须保留Phase清单」，为每个 Phase（或 2-3 个相关 Phase 合并）创建自包含分包：

```
对每个 Phase N（或合并的 Phase 组）:
  phase-bundle-N.md =
    ┌── master-context.md（完整嵌入，~500 行）
    ├── Phase N 原文（完整，从源 PRD 按行号范围提取）
    └── Phase N 引用的表/规则/UI（从源 PRD 精选引用的章节内容）

每个分包目标: ~800-1300 行
```

**分包合并规则：**
- 如果单 Phase 原文 < 300 行 → 与相邻 Phase 合并
- 如果单 Phase 原文 > 800 行 → 单独成包
- 最终分包数量 ≤ 8（超过则合并小 Phase）

写入分包: `$PROJECT_DIR/phase-bundle-1.md`, `phase-bundle-2.md`, ...

#### 步骤 3: 并行 Subagent 处理（≤ 4 并行）

```
# 每个分包启动一个 general-purpose Subagent 生成对应 Phase 的 PRD 片段

for each phase-bundle-N.md:
  Task(
    subagent_type: "general-purpose",
    description: "生成 Phase N PRD",
    prompt: """
读取 $PROJECT_DIR/phase-bundle-N.md。

根据分包内容，生成 BotoolAgent PRD 格式的 Phase 片段。

输出必须包含:
- § 7.N Phase N 标题 + DT 列表（按 DT 分解规则拆分）
- 该 Phase 涉及的 § 3/4/5/6 设计内容（从分包中提取并格式化）
- 每个 DT 必须有完整验收条件

输出到: $PROJECT_DIR/prd-phase-N.md

⚠️ 上下文保护 — 返回消息格式：
文件写入后，返回结构化摘要（禁止复述文件内容，主对话会通过 Read 获取完整文件）：
- Phase: [Phase 名称 + DT 数量]
- 涉及维度: [§3/§4/§5/§6 哪些有内容]
- 关键发现: [高复杂度任务、跨 Phase 依赖]
控制在 10 行以内。
"""
  )
```

**最多同时 4 个 Subagent 并行**。如果分包 > 4 个，分批处理（第一批 4 个完成后启动第二批）。

#### 步骤 4: 合并校验

所有 Subagent 完成后，合并分片为最终 PRD：

```bash
# 合并所有 prd-phase-N.md → 最终 prd.md
# 在合并前添加 § 1 项目概述和 § 2 当前状态（从 master-context.md 提取）
```

**合并校验（不可跳过）：**

1. **CREATE TABLE 完整性**: `grep -c 'CREATE TABLE' prd.md` ≥ T1 表清单的 80%
2. **Phase 完整性**: 生成 PRD 中的 Phase 数量 ≥ T1「必须保留Phase清单」的 100%
3. **行数校验**: 生成 PRD 行数 ≥ 2000 行（源 PRD > 5000 行时的最低要求）
4. **冲突检测**: 检查是否有重复的 DT 编号（不同 Subagent 可能生成重叠 DT-xxx）
   - 发现重复 → 重新编号（按 Phase 顺序递增）

校验失败 → 报错并指明具体缺失项，提示用户手动补充或重新运行。

**C1 完成后 → 进入 Phase T2.5（完整性校验）→ T3 → Tq → T5 → L5 → G1/W1**

---

### Phase T2: 结构发现（Standard 模式，< 2000 行）

**目标：** 从源 PRD 中提取结构信息，按 BotoolAgent 维度分类。**仅 Standard 模式（< 2000 行）使用此流程。C2/C1 模式跳过此 Phase。**

**第一遍：源章节枚举 + 显式映射（Source-First）**

**核心原则：先枚举源 PRD 所有章节，再逐一映射到目标维度。禁止"找不到关键词就跳过"。**

1. 使用 Grep `^#{1,4}\s` 提取所有标题 → 得到 TOC + 行号
2. 按行号计算每个章节的大小
3. 对 T1「源章节清单」中的每个源章节，进行**显式映射**：

**关键词优先映射表（扩充版）：**

| 关键词（含于章节标题） | 目标维度 |
|------------------------|---------|
| 背景/概述/目标/定位/Introduction/Summary/产品概述/产品定位 | § 1 项目概述 |
| 当前/状态/现有/Current/Existing/现状/已有/能力 | § 2 当前状态 |
| 架构/设计/系统/Architecture/System/分类体系/版本管理/槽位/翻译架构/状态机/多语言 | § 3 架构设计 |
| 数据/Schema/表/Database/Model/字段/SQL/建表/迁移/migration | § 4 数据设计 |
| UI/界面/页面/组件/Component/布局/交互/弹窗/线框/视图/界面设计 | § 5 UI 设计 |
| 规则/约束/权限/Rule/Constraint/流程/**格式**/**导入**/**导出**/**converter**/**文件格式**/**上传** | § 6 业务规则 |
| 开发/Phase/阶段/计划/Task/任务/里程碑/Sprint/Roadmap/实施 | § 7 开发计划 |
| 附录/风险/测试/Appendix/安全/参考/附件/实现细节/技术方案/代码示例 | § 8 附录 |
| API/端点/Endpoint/Route/路由/接口设计/REST/GraphQL | § 9+ 扩展（如无法归入 §3） |
| Changelog/变更/更新日志/会议纪要/讨论记录 | ⏭️ 跳过 |

**⚠️ 无关键词匹配的章节（Unmapped）处理规则（关键修复）：**
- 禁止将"无法匹配"的章节静默跳过
- 必须读取该章节前 30 行，基于**内容语义**判断：
  a) 如果内容可自然归入 §1-§8 某个维度 → 映射到该维度
  b) 如果内容是独立的技术规范/设计（如 API 设计、文件格式定义、DSL 规范、协议定义）且强行归入 §1-§8 会导致压缩或信息丢失 → 映射到 §9+ 扩展章节，标注原文保留
- 在工作笔记中标注：`⚠️ [源章节] → §9+ 扩展（理由: 独立技术规范，强制归入 §X 会丢失细节）`

4. 建立「源章节映射表」并记入工作笔记（**强制，不可省略**）：

```
源章节映射表:
  ✅ 源 §1 产品概述             → §1 项目概述   (1200行)
  ✅ 源 §2 数据库设计           → §4 数据设计   ( 450行)
  ✅ 源 §6 文档格式与导入导出   → §6 业务规则   (1165行)  ← 语义判断: 含格式规则/导入导出规则
  ✅ 源 §7 数据库 SQL           → §4 数据设计   ( 570行)
  ⚠️ 源 §10 附件一              → §8 附录       ( 200行)  ← 语义判断
  🔵 源 §9 API 设计              → §9+ 扩展     ( 350行)  ← 独立技术规范，原文保留
  ⏭️ 源 §11 变更记录             → 跳过 (Changelog)
  ...
  源章节总数: N 个，已映射: M 个，跳过: K 个，覆盖: 100% ← 必须 100%
```

**映射完整性要求：** T1「源章节清单」中的每个章节必须出现在映射表中（映射或跳过），不允许遗漏。

**第二遍：按维度桶充分读取（不截断）**

```
每个维度桶：
  - 计算该桶所有章节的总行数
  - 完整读取该维度桶的所有内容（不设行数上限）
  - 使用 Read 工具的 offset/limit 参数分段读取大章节
  - 提取所有设计细节：SQL 语句、代码示例、ASCII 图、状态机定义、业务规则
  - 关键内容原文保留，不要压缩或总结
```

**读取优先级：**

> ⚠️ **注意（大文件模式）：** 下列优先级标注的是 **BotoolAgent 目标维度编号**（§1-§8），不是源 PRD 的章节编号。
> 实际读取时，根据 T1 步骤 3d 识别的源 PRD 章节映射关系，找到源 PRD 中对应的章节进行读取。
> 例如，源 PRD 的"§9 开发计划"对应 BotoolAgent § 7，应作为最高优先级读取。

1. **BotoolAgent § 7 对应维度**（开发计划 — T1 识别的章节）和 **§ 4 对应维度**（数据设计）— 对 DT 分解最关键，优先读取
2. **BotoolAgent § 3 对应维度**（架构设计）和 **§ 6 对应维度**（业务规则）— 对实现质量关键
3. **BotoolAgent § 5 对应维度**（UI 设计）和 **§ 8 对应维度**（附录中的实现细节）— 对 Coding Agent 直接有用
4. **BotoolAgent § 1 对应维度**（概述）和 **§ 2 对应维度**（当前状态）— 背景信息
5. **跳过**：版本更新日志 (Changelog)、会议纪要、项目管理信息等与实现无关的内容

**Read 调用策略：**
- 不设固定上限，按需读取（模型上下文允许处理大量文本）
- 每次 Read 建议 500-1000 行，分段读取大章节
- 并行读取独立的维度桶以提高效率

**强制记录（Transform 模式，不可跳过）：**

每读完一张 CREATE TABLE（§4 数据设计维度），立即在工作笔记中记录：
  ✅ table: categories → 字段数: 8 → 字段: [id, name, slug, parent_id(自引用外键!), icon, color, ...]
  ⚠️  关键字段标注：parent_id → 两层分类结构核心，生成 PRD 时必须保留
  📊 字段数统计：每张表必须记录准确的字段数（用于 Tv 字段数校验）

每读完一个开发计划 Phase（§7 开发计划维度，即 T1 步骤 3d 识别的源 PRD 章节），立即在工作笔记中记录：
  ✅ phase: [源PRD编号] [Phase名称] → 任务数: X，涉及文件/组件: [关键列表]
  ⚠️  关键依赖标注：[依赖前一 Phase 的任务，生成 DT 时必须标注 dependsOn]

每个维度桶读取完成后，在工作笔记中标注：
  [完成] §4 数据设计 — 共读取 X 个表，总字段数 F 个，关键字段已标注 Y 个
  [完成] §7 开发计划 — 共读取 Z 个 Phase（源PRD编号：9.0-9.8 等），任务条目总计 N 条

**字段数汇总表（§4 维度完成后必填，供 Tv 校验使用）：**
```
源 PRD 字段数汇总:
  categories:           8 个字段
  documents:           12 个字段
  present_elements:    15 个字段
  ...
  总计: X 张表, Y 个字段
```

在 metadata 中设置 `transformPhase: 'extraction'`

---

### Phase T2.5：内容完整性校验（大文件模式必执行）

**目标：** 在覆盖度评分前，验证"已读内容"与"T1 预提取基准"一致，防止关键表/字段/Phase 无声消失。

**步骤：**

**A. SQL 表完整性校验**

1. 从工作笔记列出已记录的所有表名
2. 与 T1「必须保留表清单」逐条对照：
   - 已记录 ✅
   - 未记录 → 立即返回 T2 补充读取该表（不得跳过、不得"假设已读"）
3. 对照「关键字段清单」，确认 parent_id、source_type 等已被捕获

**A2. Tv 字段数校验（不可跳过）**

对「字段数汇总表」中的每张表，逐一校验字段数完整性：

1. 从工作笔记读取每张表的「已记录字段数」
2. 与 T1 步骤 3a 中 Grep 提取的 CREATE TABLE 原文逐表比对：
   - 重新 Grep 源 PRD 中该表的 CREATE TABLE 块，统计「源字段数」
   - 已记录字段数 ≥ 源字段数 → ✅ 通过
   - 已记录字段数 < 源字段数 → ⚠️ 字段数不足，返回 T2 补充读取该表
3. 输出 Tv 字段数比对结果：
   ```
   Tv 字段数校验:
     categories:    8/8   ✅
     documents:    10/12  ⚠️ 差 2 个字段 → 返回补充读取
     elements:     15/15  ✅
     总计: X/Y 表通过 (字段覆盖率 Z%)
   ```
4. 存在 ⚠️ 的表 → 返回 T2 使用 Read 重新读取该表的完整 CREATE TABLE 块，补充遗漏字段后更新工作笔记中的字段数
5. 补充完成后重新执行 Tv 校验（最多循环 2 次，防止无限循环）

**B. 开发计划 Phase 完整性校验（新增）**

4. 从工作笔记列出已记录的所有开发计划 Phase（含源 PRD 编号）
5. 与 T1「必须保留Phase清单」逐条对照：
   - 已记录 ✅
   - 未记录 → 立即返回 T2 补充读取该 Phase（不得跳过、不得"假设已读"）
6. 校验任务条目数量：从工作笔记统计「已记录任务条目总数」，与 T1「任务条目基准 N 条」对比：
   - 已记录数量 ≥ 基准 × 80% → ✅ 通过
   - 已记录数量 < 基准 × 80% → ⚠️ 任务条目存在大量遗漏，返回 T2 补充读取对应 Phase

**B2. 实体级校验（Transform 模式必须执行）**

从 T1「实体基准清单」逐类核查已提取内容的覆盖率：

| 实体类别 | 达标标准 | 不达标处理 |
|---------|---------|-----------|
| API 路由 | ≥ 90% 路由已提取 | 返回 T2 Grep 补充 |
| TypeScript 接口 | ≥ 80% 接口已提取 | 返回 T2 Grep 补充 |
| 组件名 | ≥ 80% 组件已提取 | 返回 T2 Grep 补充 |
| ASCII 图块 | ≥ 70% 图块已提取 | 返回 T2 Grep 补充 |

不达标项返回 T2 精确 Grep 源 PRD 该类内容行号 → 补充读取。最多循环 2 次。

**C. 输出校验结果**（纯文本输出，不使用 AskUserQuestion）

若全部通过：
> "✅ T2.5 校验通过：SQL 表 X/Y（关键字段均已捕获），Tv 字段数 F1/F2（覆盖率 Z%），开发计划 Phase Z/Z（任务条目 N 条，覆盖率 ≥ 80%），进入覆盖度分析。"

若有缺失：
> "⚠️ T2.5 发现缺失：
>    - [SQL 表] present_collaborators（整表缺失）→ 正在补充读取...
>    - [Tv 字段数] documents 10/12 字段（差 2 个）→ 正在补充读取...
>    - [SQL 字段] categories.parent_id（字段未标注）→ 正在补充标注...
>    - [开发Phase] Phase 9.3（整节缺失）→ 正在补充读取...
>    - [任务条目] 已记录 45 条，基准 120 条（覆盖率 37%）→ 正在补充读取 Phase 9.4-9.8..."
> 补充完成后，重新执行步骤 A-C（含 Tv）直至全部通过。

**D. 源章节覆盖完整性校验（新增，不可跳过）**

此步骤解决"整章内容漏网而不触发警报"的根本缺陷。

7. 从工作笔记提取「源章节映射表」，核对「源章节清单」：
   - 每个需处理的源章节均已出现在映射表中 ✅
   - 发现未在映射表中的源章节 → 立即执行语义判断 + 补充映射 + 读取

8. 对映射到 **§6 业务规则** 的所有源章节，逐一核查读取完整性：
   - 该源章节总行数（来自 T1 3e）vs 已读行数（来自工作笔记）
   - 已读行数 ≥ 总行数 × 70% → ✅
   - 已读行数 < 总行数 × 70% → ⚠️ 必须补充读取（对大型业务规则章节，这是最高风险点）
   - 同样的检查也适用于映射到 §3/§5/§8 的大型源章节（> 300 行的章节）

9. 更新校验结果输出，包含源章节覆盖统计：
   > "✅ T2.5 全部通过：SQL 表 X/Y，Phase Z/Z，源章节 M/N（其中 §6 映射章节已读 P/Q 行，覆盖率 R%）"

   > "⚠️ T2.5 发现源章节覆盖不足：
   >    - [源章节] §6 文档格式与导入导出（1165行，已读 200行，覆盖 17%）→ 正在补充读取..."
   > 补充完成后，重新执行步骤 D 直至全部通过。

**跳过条件：**
- **Transform 模式: 不可跳过**（所有文件大小档位均必须执行全部步骤）
- 功能开发/完整规划模式: 源 PRD < 5000 行可跳过

---

### Phase T3: 维度覆盖度评分

**目标：** 对每个 BotoolAgent 维度打分，决定后续动作。

#### 覆盖度级别

| 覆盖度 | 图示 | 含义 | 后续动作 | 摘录策略 |
|--------|------|------|----------|----------|
| FULL | ████ | 内容充分，可直接提取 | 自动映射，不提问 | **原文摘录**：SQL、代码、ASCII 图、规则表逐字复制到生成 PRD |
| HIGH | ███░ | 基本覆盖，有小模糊点 | 1-2 个确认性问题 | **原文摘录 + 补充**：核心内容逐字复制，模糊点通过问答补充后写入 |
| PARTIAL | ██░░ | 部分内容，关键部分缺失 | 3-5 个针对性问题 | **部分摘录 + 生成**：已有内容摘录，缺失部分通过问答生成 |
| SPARSE | █░░░ | 几乎没有内容 | 复用现有 L2/L3 问题模板 | **全部生成**：通过问答从零生成该维度内容 |

#### 评分标准

| 维度 | FULL | HIGH | PARTIAL | SPARSE |
|------|------|------|---------|--------|
| § 1 概述 | 有目标+指标+背景 | 有目标无指标 | 只有项目名 | 无 |
| § 3 架构 | 有架构图+角色+流程 | 有高层设计 | 提到架构 | 无 |
| § 4 数据 | 有 SQL/ORM + 字段+约束 | 有表+部分字段 | 提到表名 | 无 |
| § 5 UI | 有线框图+页面+组件清单 | 有页面列表 | 提到页面 | 无 |
| § 6 规则 | 有规则表+决策树 | 有规则描述 | 提到约束 | 无 |
| § 7 计划 | 有 Phase+细粒度任务+文件 | 有 Phase+粗任务 | 有任务列表 | 无 |

#### 展示覆盖度分析

**前置要求：** T3 展示覆盖度分析时，必须同时展示「源章节映射表」（来自工作笔记）。这是双向可见性的核心：让用户看到**每个源章节去了哪里**，而不只是看到目标维度覆盖了多少。

使用 AskUserQuestion 向用户展示覆盖度分析结果：

```json
{
  "questions": [
    {
      "question": "───────── 源章节映射 ─────────\n（每个源章节的去处，基于 T2 实际读取结果）\n┌────────────────────────────┬──────────┬──────┐\n│ 源章节                     │ 映射到   │ 行数 │\n├────────────────────────────┼──────────┼──────┤\n│ §1 产品概述                │ §1       │ 1200 │\n│ §6 文档格式与导入导出       │ §6 ✅    │ 1165 │\n│ §7 数据库 SQL              │ §4       │  570 │\n│ §11 变更记录               │ ⏭️ 跳过  │  300 │\n└────────────────────────────┴──────────┴──────┘\n注：⚠️标注的行代表通过语义判断映射的章节，请确认无误。\n\n───────── BotoolAgent 维度覆盖度 ─────────\n┌────────────────┬──────┬──────────────────────────┐\n│ 维度           │ 覆盖 │ 说明                      │\n├────────────────┼──────┼──────────────────────────┤\n│ § 1 项目概述    │ ████ │ 充分 — 直接提取            │\n│ § 3 架构设计    │ ███░ │ 高 — 需确认角色权限        │\n│ § 4 数据设计    │ ████ │ 充分 — 含 SQL Schema      │\n│ § 5 UI 设计     │ ██░░ │ 部分 — 缺组件清单/布局    │\n│ § 6 业务规则    │ █░░░ │ 稀缺 — 需补充             │\n│ § 7 开发计划    │ ███░ │ 高 — Phase 级，需拆解 DT   │\n└────────────────┴──────┴──────────────────────────┘\n\n将对覆盖不足的维度进行针对性问答。\n§ 7 的 Phase 级任务将自动拆解为开发任务 (DT)。\n\n确认后开始补充问答？",
      "header": "覆盖度分析",
      "options": [
        { "label": "确认，开始补充", "description": "对覆盖不足的维度进行针对性问答" },
        { "label": "跳过补充，直接转换", "description": "以现有内容直接生成，缺失部分留空" }
      ],
      "multiSelect": false
    }
  ],
  "metadata": {
    "source": "pyramidprd",
    "level": 2,
    "levelName": "Transform: 覆盖度分析",
    "progress": "T3/T6",
    "totalLevels": 5,
    "transformPhase": "gap-analysis",
    "gapAnalysis": {
      "dimensions": [
        { "section": "§ 1", "name": "项目概述", "coverage": "full", "note": "充分 — 直接提取" }
      ]
    }
  }
}
```

**注意：** 上方 ASCII 表格中的内容应根据实际分析结果动态生成，示例仅供参考格式。

用户确认后进入 Phase T4。如果用户选择「跳过补充」，直接跳到 Phase T5。

---

### Phase T4: Tq 针对性问答（方案卡，仅 PARTIAL/SPARSE 维度）

**核心原则：不重复问用户 PRD 中已有的内容。只对覆盖不足的维度使用方案卡补充。**

#### 问题选取规则

| 维度覆盖度 | 选题来源 | 问题数 |
|-----------|---------|--------|
| § 5 UI = PARTIAL | L2 uiStructure（页面列表、组件、布局） | 2-4 |
| § 6 规则 = SPARSE | L3 业务规则 + 状态流转 + L2 backend（权限、约束） | 3-5 |
| § 3 架构 = PARTIAL | L2 architecture（跳过已有高层设计） | 2-3 |
| § 4 数据 = PARTIAL | L2 dataModel（跳过已有表名，只问缺失字段/约束） | 2-4 |

#### Tq 方案卡模板

```
【Transform Tq — AI 补充方案卡】

覆盖不足维度: [§5 UI (PARTIAL), §6 规则 (SPARSE)]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
§5 补充:
  Q1. 页面数: A) 2个 ← 推断  B) 3个  C) 我来列
  → AI 选择: A

§6 补充:
  Q2. 删除策略: A) 软删除 ← 安全  B) 硬删除+确认
  → AI 选择: A

  Q3. 权限控制: A) 管理员才能删 ← 推荐  B) 所有用户
  → AI 选择: A
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
要修改请在下方 Type something 中输入如 "Q2 换 B"
```

**使用方案卡交互协议**发送 1 个 AskUserQuestion（header: "Tq 补充问答"）。

**3 个固定选项同 L1-L4 方案卡**：全部接受 / 方向不对重新生成 / 输入修改。

**限制：最多 2 轮方案卡**（第 1 轮 PARTIAL/SPARSE 全覆盖，第 2 轮仅处理用户修改后新增的不确定项）。

**Tq 完成后 → Write journal §Tq** → 进入 T5 DT 分解

---

### Phase T5: DT 分解算法

**目标：** 将用户 PRD 的 Phase 级任务拆解为迭代级 DT。这是 Transform Mode 的核心价值。

在 metadata 中设置 `transformPhase: 'dt-decomposition'`

#### 分解规则

| 用户任务关键词 | 拆分策略 |
|---------------|---------|
| CRUD / 增删改查 | 4 个 DT（每个操作一个） |
| 管理页面 | 3-4 个 DT（列表 + 表单 + 详情 + 路由） |
| 翻译/国际化 | 3-5 个 DT（API + 状态机 + 进度 UI + 集成） |
| 导入导出 | 2-3 个 DT（解析器 + UI + 集成） |
| 审批流 | 4-5 个 DT（Schema + 状态机 + API + UI + 通知） |

#### 分解流程

```
对每个用户 Phase:
  1. 计数「scope 信号」：API 路由数 + 页面数 + 新建表数 + 组件数
  2. 信号 ≤ 2 → 保持为 1 个 DT
  3. 信号 3-5 → 按层拆分（DB → API → UI），2-3 个 DT
  4. 信号 6+ → 按功能切片拆分，4-7 个 DT
  5. 每个 DT 生成：
     - 标题含文件/API/组件引用
     - 验收条件（从用户 PRD 提取 + 改写）
     - prdSection 指向生成的 PRD § 7.X
     - dependsOn 依赖链
```

#### DT 格式（写入 BotoolAgent PRD § 7）

```markdown
### 7.2 Phase 2: 文档库管理 (P0)

> **前置**: Phase 1
> **产出**: 管理员可创建/编辑/管理 PPT 文档
> **对应设计**: Section 3.5-3.6, 8.9

- [ ] DT-005: 文档库列表 API (GET /api/presentations, 含分页+筛选) (`文件: app/api/presentations/route.ts`)
- [ ] DT-006: 文档库管理页面 — 列表视图 (`组件: <DocumentLibrary>`, `页面: /library/admin`)
- [ ] DT-007: 新增 PPT 功能 (POST /api/presentations + 编辑器跳转) (`文件: app/api/presentations/route.ts`)
- [ ] DT-008: 分享功能 — API + ShareDialog 组件 (`API: /api/presentations/[id]/collaborators`, `组件: <ShareDialog>`)
- [ ] DT-009: 访问请求 — API + AccessRequestView (`API: /api/presentations/[id]/access-requests`, `组件: <AccessRequestView>`)
```

---

### Phase T6: 收敛到 L5 确认门控

**目标：** DT 分解完成后，收敛到现有的 L5 确认门控流程。

```
Phase T6 输出 → Phase 5.8 (Compact 检查点) → 喂入现有 Phase 6 (L5 Confirmation Gate, 2 轮 Tabs)
  第 1 轮: 项目概述 | 核心架构 | 用户角色 | 核心工作流
  第 2 轮: 数据模型 | 关键 UI  | 业务规则 | 总确认
```

**Compact 检查点：** T6 完成后、L5 开始前，执行 Phase 5.8（Compact 检查点），给用户压缩对话的机会。

**按模式裁剪 L5 步骤：** Transform 模式使用与「完整规划」相同的 L5 配置（2 轮 x 4 Tabs 全部展示），因为用户的原始 PRD 通常涵盖较多维度。

用户确认后，进入 Phase 7（PRD 生成）生成标准 BotoolAgent PRD。

---

### Transform Mode: PRD 生成规则（Phase 7 特化）

**Transform 模式生成 PRD 时，除遵循通用 Phase 7 模板外，还必须遵守以下充分摘录规则：**

#### 核心原则：复制粘贴优先，禁止重写

> **Transform 模式的默认动作是「复制粘贴」，不是「理解后重写」。**
> 重写必然丢失细节。只有章节标题和连接性文字使用 BotoolAgent 格式，内容体一律从源 PRD 原文复制。
> 生成的 BotoolAgent PRD **必须是自给自足的文档**。Coding Agent 不应需要回读源 PRD。

#### 不可重写内容清单（Must Copy Verbatim）

以下内容类型 **禁止用自己的话重写**，必须从源 PRD 逐字复制粘贴：

| 内容类型 | 识别方式 | 复制规则 |
|---------|---------|---------|
| **ASCII 图**（线框图/流程图/架构图/依赖图） | 代码块内含 `┌│└─▶├┤┬┴╋━═` 或 `+--\|` 或缩进的框图结构 | 整个代码块逐字复制，包括所有空格对齐，不可"简化"或"重画" |
| **SQL CREATE TABLE** | `CREATE TABLE` 关键字 | 从 `CREATE TABLE` 到 `);` 逐字复制，含所有字段、约束、注释、默认值 |
| **代码示例**（TypeScript/JavaScript/SQL/Shell） | 代码块内含 `function`/`const`/`import`/`export`/`SELECT`/`async` | 整个代码块逐字复制 |
| **Markdown 表格** | `\|` 分隔的多列结构 | 整个表格逐行复制，不可删列、不可合并行 |
| **编号规则/原则列表** | `1.`/`-`/`*` 开头的条目清单，含设计原则、业务规则、安全规则 | 逐条复制，不可精简为"共 N 条"或"详见附录" |
| **API 端点定义** | `(GET\|POST\|PUT\|DELETE\|PATCH) /api/` | 逐条复制路径、HTTP 方法、说明 |
| **目录树/文件结构** | 含 `├──`/`└──`/`│` 的 tree 图 | 整个树结构逐字复制 |
| **状态机/决策树定义** | 含 `→`/`──▶`/状态转换箭头的块 | 整个定义块逐字复制 |

**违规判定**：如果源 PRD 中存在上述内容类型的实例，但生成 PRD 中对应位置是一句总结（如"详见源 PRD"、"包含 N 个表"、"架构图如下"但无实际图），则判定为违规丢失。

#### 各维度操作指令（复制 vs 包装）

| 维度 | 操作 | 说明 |
|------|------|------|
| **§ 1 项目概述** | **复制**: 设计原则表/核心原则列表 → 逐条复制到 §1。**包装**: 背景叙述可精简为 1-2 段 | 设计原则是 coding agent 的决策基础，绝不可省略 |
| **§ 3 架构设计** | **复制**: 所有 ASCII 架构图、URL 路由表、技术栈表、认证流程、状态机定义、目录树、代码示例。**包装**: 仅添加 BotoolAgent 章节标题 | 架构章节几乎 100% 复制，精简空间极小 |
| **§ 4 数据设计** | **复制**: 所有 CREATE TABLE、ER 图、约束表、迁移映射。**包装**: 添加 §4.1 概览表格 | SQL 是逐字复制的典型场景 |
| **§ 5 UI 设计** | **复制**: 所有 ASCII 线框图（页面布局 + 弹窗 + 面板）、组件表、交互流程图。**包装**: 添加页面清单表 | 线框图丢失 = UI 实现质量崩溃 |
| **§ 6 业务规则** | **复制**: 所有规则表格、决策树、流程图、恢复规则、运行时策略。**包装**: 按领域分组添加标题 | 规则表格不可压缩，一条都不能少 |
| **§ 8 附录** | **复制**: 代码文件索引、技术实现代码示例（全部）、API 归属分析表、清理变更清单。**包装**: 添加风险/测试/安全附录 | 代码示例是 coding agent 的直接参考 |
| **§ 9+ 扩展** | **复制**: 整章原文复制（如独立的 API 设计章节、共享包设计章节）。**包装**: 仅添加来源标注 | §9+ 章节本质就是「源 PRD 原文搬运」 |
| **§ 7 开发计划** | **特殊**: 使用 T5 DT 分解算法的输出，不复制源 PRD 的 Phase 列表。但验收条件从源 PRD **复制**关键点 | 唯一允许"重写"的维度 |

#### 可省略内容（仅以下 4 类允许省略）

- **版本更新日志** (Changelog) — 与实现无关
- **会议纪要/讨论记录** — 与实现无关
- **重复的叙述性描述** — 同一信息出现多次时，只保留最完整的版本
- **项目管理信息**（负责人、截止日期等）— BotoolAgent 有自己的进度管理

**除以上 4 类外，源 PRD 的任何技术内容都不允许省略。如果你觉得某段内容"不重要"，请复制它而不是省略它。**

#### 预期文档长度（最低行数要求）

| 源 PRD 长度 | 生成 PRD 最低行数要求 | 说明 |
|------------|----------------------|------|
| < 500 行 | ≈ 源 PRD 的 1.5-2x | 补充缺失维度会增加内容 |
| 500-2000 行 | ≈ 源 PRD 的 0.8-1.5x | 复制粘贴 + 结构化重组 |
| 2000-5000 行 | 最低 源 PRD 的 80% | 去冗余后核心内容全部保留（复制粘贴为主） |
| > 5000 行 | 最低 源 PRD 的 70% | 大文件去冗余后仍应保持高信息密度 |

#### 强制自检（Transform 模式，生成完毕后必须执行）

生成 PRD 完成后，执行以下自检：

1. **CREATE TABLE 完整性**: `grep -c "CREATE TABLE" prd.md` ≥ T1 表清单的 100%
2. **ASCII 图完整性**: 统计 prd.md 中代码块数量 vs T1「ASCII 图块基准数」≥ 80%
3. **API 端点完整性**: Grep 每条 T1「API 路由基准清单」中的路由 → 必须 100% 存在
4. **行数校验**: `wc -l prd.md` ≥ 源 PRD 行数 × 80%（2000-5000 行档位）
5. **原则/规则完整性**: 源 PRD 中的编号列表（如"核心原则 1-6"）在生成 PRD 中条目数必须一致

生成失败条件（满足任一 → 必须从 prd_original.md 补充复制缺失内容，不可跳过）：
- ❌ CREATE TABLE 数量 < 源 PRD 的 100%
- ❌ ASCII 图块数 < T1 基准的 80%
- ❌ 任何 API 路由在生成 PRD 中找不到
- ❌ 生成 PRD 行数 < 源 PRD 的 80%（2000-5000 行档位）
- ❌ 编号原则/规则列表条目数少于源 PRD

满足上述失败条件时，从 prd_original.md 定位缺失内容段落 → 直接复制粘贴追加到 prd.md 对应章节。

#### 文件管理

**自动检测 tasks 目录（兼容 standalone 和 portable 模式）：**
```bash
TASKS_DIR="$([ -d BotoolAgent/tasks ] && echo BotoolAgent/tasks || echo tasks)"
PROJECT_DIR="$TASKS_DIR/<projectId>"
mkdir -p "$PROJECT_DIR"
```

```
$TASKS_DIR/
  <projectId>/
    DRAFT.md                 ← 用户原始 Draft（如从 brainstorm 导入）
    prd_original.md          ← 源 PRD 备份（Ti 阶段创建，Tf 字段级比对基准）
    prd.md                   ← 生成的 BotoolAgent PRD（标准格式）
    dev.json                 ← 自动化执行用 JSON
  registry.json              ← 项目注册表
```

用户原始文件不动，不复制。BotoolAgent PRD 写入项目子目录 `$PROJECT_DIR/prd.md`。

---

### Phase T7: 生成后原文比对（Post-Generation Diff）

**目标：** PRD 写入文件后，系统性比对生成 PRD 与源 PRD，量化覆盖率，发现并补救关键内容丢失。

**触发条件：**
- **Transform 模式: 必须执行**（所有文件大小档位）
- 大文件模式（源 PRD > 5000 行）**必须执行**
- 其他模式小文件可选执行（默认执行）
- 触发时机：Phase 7 生成完毕、文件写入磁盘后，PRD2JSON 转换前

#### 步骤 1：逐维度行数比对

从工作笔记提取「源章节映射表」，统计每个目标维度的**源行数**；读取生成 PRD 对应章节的**实际行数**。

```
对每个 BotoolAgent 维度 §1-§8：
  源行数 = sum(映射到该维度的所有源章节行数)
  生成行数 = 生成 PRD 中该维度章节的行数（通过 Grep 章节标题 + wc 统计）
  覆盖率 = 生成行数 / 源行数 × 100%
```

覆盖率阈值：

**功能开发/完整规划模式（原有阈值）：**

| 维度 | 最低覆盖率 | 说明 |
|------|-----------|------|
| § 4 数据设计 | 60% | SQL 语句为主，行数天然压缩 |
| § 6 业务规则 | **40%** | 重点维度，低于此值必须补充 |
| § 3 架构设计 | 30% | 状态机/流程图可摘要 |
| § 5 UI 设计 | 25% | 线框图可简化 |
| § 7 开发计划 | N/A | 由 T5 DT 分解产生，不按行数比较 |
| § 8 附录 | 20% | 可精简 |

**Transform 导入模式（高保真阈值）：**

| 维度 | 最低覆盖率 | 说明 |
|------|-----------|------|
| § 4 数据设计 | 90% | SQL 语句必须完整保留 |
| § 6 业务规则 | 80% | 规则表格/决策树不可压缩 |
| § 3 架构设计 | 80% | 状态机/流程图完整复制 |
| § 5 UI 设计 | 70% | 线框图原文保留 |
| § 7 开发计划 | N/A | 由 T5 DT 分解产生，不按行数比较 |
| § 8 附录 | 60% | 实现细节不可省略 |
| § 9+ 扩展 | 90% | 独立技术规范原文保留 |

#### 步骤 1.5：实体级比对（Transform 模式主门控）

**Transform 模式时此步骤为主门控，非 Transform 模式跳过。**

1. 从 T1「实体基准清单」逐一 Grep 核查每个实体是否出现在 prd.md 中：

| 实体类别 | 核查方式 | 达标标准 |
|---------|---------|---------|
| API 路由 | Grep 每条路由路径 | 100% 存在 |
| CREATE TABLE | Grep 每个表名 | 100% 存在 |
| TypeScript 接口 | Grep 每个接口名 | 90% 存在 |
| 组件名 | Grep 每个组件名 | 90% 存在 |
| ASCII 图块 | 统计 prd.md 图块数 vs 基准 | ≥ 70% |

2. 不达标 → ❌ 标记，步骤 4 从 prd_original.md 定位缺失实体所在段落，追加到 prd.md

#### 步骤 2：关键词内容核查

对以下高价值内容，使用 Grep 在生成 PRD 中核查是否存在：

| 核查内容 | 在源 PRD 中存在的信号 | 核查方式 |
|---------|---------------------|---------|
| 格式支持矩阵 | 源 §6 含 "导入/导出" + 表格 | Grep `\|.*导入.*\|` 或 `format.*matrix` |
| 安全规则 | 源含 SSRF/XSS/ZIP/injection | Grep `SSRF\|XSS\|ZIP 炸弹\|注入` |
| 元素映射规则 | 源含 6 种元素类型映射 | Grep `文本元素\|图片元素\|形状元素` |
| 定量验收标准 | 源含 % 还原率指标 | Grep `[0-9]+%.*还原\|还原率` |
| 大文件架构约束 | 源含三层分离/SSE 解耦 | Grep `三层\|SSE.*解耦\|maxDuration` |

若源 PRD 中存在某类信号，但生成 PRD 中 Grep 为空 → 该项标记为 `❌ 缺失`。

#### 步骤 2.5：DT↔prd.md 交叉检查

对生成的 PRD §7 开发计划中的每个 DT：
1. 确认该 DT 的标题和描述在 PRD §7 Phase 章节中有对应内容
2. 确认 PRD §7 Phase 章节中的每个任务条目都有对应的 DT
3. 不匹配的项标记为 ❌：
   - 孤立 DT（PRD 中无对应 Phase 内容）
   - 遗漏 DT（PRD Phase 中有任务描述但未创建 DT）
4. ❌ 项在步骤 4 自动补充中修复

#### 步骤 2.6：SQL 字段完整性校验（Transform 模式）

**前置条件：** 存在 `$PROJECT_DIR/prd_original.md`（Ti 备份）

> 若 `prd_original.md` 不存在（非 Transform 模式或未执行 Ti 备份），跳过此步骤。

1. 从 prd_original.md（源 PRD）Grep 所有 `CREATE TABLE` 语句，提取每张表的字段列表
2. 从生成的 prd.md Grep 所有 `CREATE TABLE` 语句，提取每张表的字段列表
3. 逐表比对：
   - 源表字段列表 vs 生成表字段列表
   - 缺失字段标记为 ❌
   - 新增字段标记为 ⚠️（可能是改进，不阻塞）
4. 字段完整率 = (生成表匹配字段数 / 源表字段数) x 100%
5. 任一表完整率 < 90% → 该表标记为 ❌，步骤 4 自动补充

```
SQL 字段完整性校验：
┌──────────────────┬──────────┬──────────┬──────────┬────────┐
│ 表名             │ 源字段数 │ 匹配字段 │ 完整率   │ 状态   │
├──────────────────┼──────────┼──────────┼──────────┼────────┤
│ users            │  12      │  12      │  100%    │ ✅     │
│ documents        │  18      │  16      │   89%    │ ❌     │
│ templates        │   8      │   8      │  100%    │ ✅     │
└──────────────────┴──────────┴──────────┴──────────┴────────┘
缺失字段：documents.archived_at, documents.version
新增字段（⚠️ 不阻塞）：documents.updated_by
```

#### 步骤 3：输出比对报告（纯文本，**不打断流程，不等待用户**）

直接输出比对结果，**发现 ❌ 立即进入步骤 4 自动补充，不使用 AskUserQuestion，不停下来问用户**：

```
───────── T7 生成后原文比对报告 ─────────

维度覆盖率：
┌────────────┬──────────┬──────────┬──────────┬────────┐
│ 维度       │ 源行数   │ 生成行数 │ 覆盖率   │ 状态   │
├────────────┼──────────┼──────────┼──────────┼────────┤
│ §4 数据    │  570行   │  400行   │  70%     │ ✅     │
│ §6 规则    │ 1165行   │   70行   │   6%     │ ❌     │
│ §5 UI      │  800行   │  200行   │  25%     │ ✅     │
│ §3 架构    │  600行   │  250行   │  42%     │ ✅     │
└────────────┴──────────┴──────────┴──────────┴────────┘

关键内容核查：
  ✅ CREATE TABLE (12/12)
  ❌ 格式支持矩阵 — 源 §6 有，生成 PRD 无
  ❌ SSRF/ZIP 安全规则 — 源 §6 有，生成 PRD 无
  ❌ 元素映射规则 — 源 §6 有，生成 PRD 无
  ✅ 定量验收标准
  ❌ 大文件架构约束 — 源 §6 有，生成 PRD 无

发现 ❌ 项，自动补充中...
```

若全部 ✅ 则直接输出：
> "✅ T7 比对通过，无需补充。进入下一步。"

#### 步骤 4：自动补充（发现任意 ❌ 立即执行，无需用户确认）

**原则：只要有 ❌，就补。不停下来问。**

1. 针对每个 ❌ **覆盖率不足**的维度：
   - 从「源章节映射表」取该维度对应的所有源章节行范围
   - 完整读取源章节内容（分段 Read，不截断）
   - 在生成 PRD 对应章节末尾追加缺失内容
   - 追加块起始处标注来源：`> **[T7 补充自源 PRD §X 章节名]**`

2. 针对每个 ❌ **关键内容缺失**项：
   - Grep 精确定位源 PRD 中该内容的行号
   - Read 读取该内容块
   - 原文插入到生成 PRD 最合适的位置（§6 规则章节 或 §8 附录）
   - 同样以 `> **[T7 补充]**` 标注来源

3. 补充完成后**立即重新执行步骤 1-2 自检**（无需等待）：
   - 所有 ❌ → ✅ 或 ⚠️（覆盖率达阈值）：通过
   - 仍有 ❌ → 继续补充（最多循环 2 次，防止无限循环）

4. 输出最终结果（纯文本，继续流程）：
   > "✅ T7 自动补充完成：追加 X 行，§6 覆盖率 6% → Y%，关键内容核查全部通过。"

   若 2 次循环后仍有 ❌：
   > "⚠️ T7 警告：[残余 ❌ 项] 已补充 2 轮仍未完全覆盖，建议事后人工检查生成 PRD §6。继续进入下一步。"

---

## 关键原则

1. **方向先行** - 功能开发/完整规划模式先走 L0 方向探索，建立共识后再深入
2. **立即开始提问** - 收到需求后先评估模式，然后按流程开始 L0 或 L1，不做冗长分析
3. **使用 AskUserQuestion** - 所有问题都通过工具提问
4. **包含 metadata** - 每次提问必须带 level 信息
5. **层级递进** - 严格按 L0→L1→S1→R1→L2→L3→L4→Phase 5.5→Phase 5.8（Compact 检查点）→L5（确认）顺序
6. **动态调整** - 根据答案调整后续问题
7. **简洁反馈** - 每层完成后简短总结，立即进入下一层
8. **ASCII 可视化** - L5 门控和 PRD 文档中使用 ASCII 图表达架构/UI/数据/流程
9. **高颗粒度** - DT 必须包含具体的 API 路径、组件名、文件路径
10. **交叉引用** - Phase 必须标注对应的设计 Section
11. **规范一致性** - 所有模式使用 R1 规范确认流程（有 rules/ 时自动扫描、用户确认、结果写入 qa-journal.md）

---

## 完成后 — PRDing Ralph 编排器

PRD 生成（Phase 7 写入 prd.md）完成后，**自动启动 PRDing Ralph 后台编排器**执行 A1(PRDReview) + A2(PRD2JSON) 管线。用户无需手动运行这两个 skill。

### 流程概要

```
PyramidPRD 主对话 → Phase 7 生成 prd.md
  ├─ 1. pipeline.lock 检查 + 创建
  ├─ 2. Task(run_in_background) 启动 PRDing Ralph
  ├─ 3. 告知用户 "后台自动执行中，可继续其他工作"
  └─ PyramidPRD 返回，主对话结束

PRDing Ralph（Background Agent）:
  ├─ A1: Skill("botoolagent-prdreview") → 对抗审查
  ├─ A2: Skill("botoolagent-prd2json") → 生成 dev.json + registry
  ├─ 成功 → 删除 pipeline.lock → 通知用户
  └─ 失败 → 删除 pipeline.lock → 通知用户 + 打印恢复指令
```

### Step 1: pipeline.lock 检查与创建

在启动编排器之前，必须检查并创建 pipeline.lock 防止并发执行。

```bash
LOCK_FILE="$PROJECT_DIR/pipeline.lock"
```

**检查逻辑：**
1. 如果 `$LOCK_FILE` 存在：
   - 读取其中的 PID 和时间戳
   - 如果 PID 进程仍存活 **且** 时间戳距今 < 30 分钟 → 告知用户 "管线正在运行中，请稍候" 并**跳过**编排器启动
   - 如果 PID 进程已死 **或** 时间戳距今 >= 30 分钟（TTL 过期）→ 视为过期，删除旧 lock 继续
2. 如果 `$LOCK_FILE` 不存在 → 继续

**创建 lock 文件：**
写入以下 JSON 内容到 `$LOCK_FILE`：
```json
{
  "pid": "<当前进程 PID>",
  "startedAt": "<ISO 8601 时间戳>",
  "projectId": "<projectId>",
  "ttlMinutes": 30
}
```

### Step 2: 启动 PRDing Ralph 后台编排器

使用 Task 工具启动后台编排器：

```
Task(
  run_in_background: true,
  subagent_type: "general-purpose",
  prompt: 见下方编排器 prompt
)
```

**编排器 prompt 模板：**

```
你是 PRDing Ralph — BotoolAgent PRD 后处理编排器。
你的任务是依次执行 A1(PRDReview) 和 A2(PRD2JSON) 管线。

项目信息:
- projectId: <projectId>
- PROJECT_DIR: <PROJECT_DIR 的绝对路径>
- TASKS_DIR: <TASKS_DIR 的绝对路径>
- prd.md 路径: <PROJECT_DIR>/prd.md

## 执行步骤

### A1: PRD 审查
执行: Skill("botoolagent-prdreview", args: "<projectId>")
- 如果审查通过或仅有 advisory → 继续 A2
- 如果审查发现 HIGH severity 问题 → 记录问题，仍继续 A2（审查结果供用户参考）

### A2: PRD 转 JSON
执行: Skill("botoolagent-prd2json", args: "<projectId>")
- 此步骤会生成 dev.json 和更新 registry.json

## 完成处理

### 成功时:
1. 删除 pipeline.lock: 使用 Bash 执行 rm -f <PROJECT_DIR>/pipeline.lock
2. 输出完成消息:
   "✅ PRDing Ralph 完成:
   - A1 PRDReview: [通过/有发现(N条)]
   - A2 PRD2JSON: dev.json 已生成
   用户可运行 /botoolagent-coding 开始自动开发。"

### 失败时:
1. 删除 pipeline.lock: 使用 Bash 执行 rm -f <PROJECT_DIR>/pipeline.lock
2. 输出错误消息和恢复指令:
   "❌ PRDing Ralph 失败于 [A1/A2]:
   错误: <错误信息>

   手动恢复指令:
   /botoolagent-prdreview <projectId>
   /botoolagent-prd2json <projectId>"
```

### Step 3: 告知用户

编排器启动后，**立即**向用户输出以下消息（不等待编排器完成）：

```
"PRD 已生成并保存到 <PROJECT_DIR>/prd.md。

后台已自动启动 PRDing Ralph 编排器，正在执行：
1. PRD 对抗审查 (PRDReview)
2. PRD 转 JSON (PRD2JSON → dev.json + registry)

你可以继续其他工作，编排器完成后会自动通知你结果。
完成后运行 /botoolagent-coding 即可开始自动开发。"
```

### 降级处理

如果 Task 工具调用本身失败（例如工具不可用）：

1. 删除已创建的 pipeline.lock
2. 告知用户并提供手动恢复指令：

```
"PRD 已生成，但后台编排器启动失败。请手动执行以下步骤：
1. /botoolagent-prdreview <projectId>
2. /botoolagent-prd2json <projectId>
3. /botoolagent-coding 开始自动开发"
```
