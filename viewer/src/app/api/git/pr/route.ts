import { NextRequest, NextResponse } from 'next/server';
import { exec } from 'child_process';
import { promisify } from 'util';
import path from 'path';
import fs from 'fs/promises';
import { getProjectRoot, getProgressPath, getPrdJsonPath, getProjectPrdJsonPath, getProjectProgressPath } from '@/lib/project-root';

const execAsync = promisify(exec);

const PROJECT_ROOT = getProjectRoot();

interface PRInfo {
  number: number;
  title: string;
  url: string;
  state: 'open' | 'closed' | 'merged';
  draft: boolean;
  mergeable: boolean | null;
  additions: number;
  deletions: number;
  changedFiles: number;
  createdAt: string;
  updatedAt: string;
}

interface CompletedTask {
  id: string;
  title: string;
}

/**
 * Parse progress.txt to extract completed task IDs and titles
 */
async function getCompletedTasks(projectId?: string): Promise<CompletedTask[]> {
  const progressPath = getProjectProgressPath(projectId);
  const tasks: CompletedTask[] = [];

  try {
    const content = await fs.readFile(progressPath, 'utf-8');
    // Match pattern: ## DATE - TASK_ID
    const taskMatches = content.matchAll(/## [\d\-\/\:\s]+ - (DT-\d+)/g);

    for (const match of taskMatches) {
      tasks.push({
        id: match[1],
        title: '', // Will be filled from PRD
      });
    }
  } catch {
    // progress.txt might not exist
  }

  return tasks;
}

/**
 * Get task titles from prd.json
 */
async function getTaskTitles(taskIds: string[], projectId?: string): Promise<Map<string, string>> {
  const prdPath = getProjectPrdJsonPath(projectId);
  const titleMap = new Map<string, string>();

  try {
    const content = await fs.readFile(prdPath, 'utf-8');
    const prd = JSON.parse(content);

    if (prd.devTasks && Array.isArray(prd.devTasks)) {
      for (const task of prd.devTasks) {
        if (taskIds.includes(task.id)) {
          titleMap.set(task.id, task.title);
        }
      }
    }
  } catch {
    // prd.json might not exist or be invalid
  }

  return titleMap;
}

/**
 * Generate PR title from project name and branch
 */
async function generatePRTitle(projectId?: string): Promise<string> {
  const prdPath = getProjectPrdJsonPath(projectId);

  try {
    const content = await fs.readFile(prdPath, 'utf-8');
    const prd = JSON.parse(content);

    if (prd.project) {
      return `feat: ${prd.project}`;
    }
  } catch {
    // Use branch name as fallback
  }

  // Fallback: use branch name
  const { stdout } = await execAsync('git branch --show-current', { cwd: PROJECT_ROOT });
  const branch = stdout.trim();
  return `feat: ${branch}`;
}

/**
 * Generate PR description with completed tasks
 */
async function generatePRDescription(projectId?: string): Promise<string> {
  const completedTasks = await getCompletedTasks(projectId);
  const taskIds = completedTasks.map(t => t.id);
  const titleMap = await getTaskTitles(taskIds, projectId);

  // Fill in titles
  for (const task of completedTasks) {
    task.title = titleMap.get(task.id) || task.id;
  }

  // Get PRD description
  let projectDescription = '';
  try {
    const prdPath = getProjectPrdJsonPath(projectId);
    const content = await fs.readFile(prdPath, 'utf-8');
    const prd = JSON.parse(content);
    projectDescription = prd.description || '';
  } catch {
    // Ignore errors
  }

  // Build description
  const lines: string[] = [
    '## Summary',
    '',
    projectDescription || 'Automated PR created by BotoolAgent.',
    '',
  ];

  if (completedTasks.length > 0) {
    lines.push('## Completed Tasks');
    lines.push('');
    for (const task of completedTasks) {
      lines.push(`- [x] **${task.id}**: ${task.title}`);
    }
    lines.push('');
  }

  lines.push('---');
  lines.push('*Generated by BotoolAgent*');

  return lines.join('\n');
}

/**
 * Check if gh CLI is available
 */
async function checkGhCli(): Promise<boolean> {
  try {
    await execAsync('gh --version', { cwd: PROJECT_ROOT });
    return true;
  } catch {
    return false;
  }
}

/**
 * Check if user is authenticated with gh
 */
async function checkGhAuth(): Promise<boolean> {
  try {
    await execAsync('gh auth status', { cwd: PROJECT_ROOT });
    return true;
  } catch {
    return false;
  }
}

/**
 * GET /api/git/pr
 * Returns the PR status for current branch
 */
export async function GET() {
  try {
    // Check gh CLI
    if (!await checkGhCli()) {
      return NextResponse.json(
        { error: 'GitHub CLI (gh) is not installed' },
        { status: 500 }
      );
    }

    if (!await checkGhAuth()) {
      return NextResponse.json(
        { error: 'Not authenticated with GitHub. Run "gh auth login" first.' },
        { status: 401 }
      );
    }

    // Get current branch
    const { stdout: branchStdout } = await execAsync('git branch --show-current', {
      cwd: PROJECT_ROOT,
    });
    const currentBranch = branchStdout.trim();

    // Check if PR exists for this branch
    try {
      const { stdout: prJson } = await execAsync(
        `gh pr view --json number,title,url,state,isDraft,mergeable,additions,deletions,changedFiles,createdAt,updatedAt`,
        { cwd: PROJECT_ROOT }
      );

      const prData = JSON.parse(prJson);

      const prInfo: PRInfo = {
        number: prData.number,
        title: prData.title,
        url: prData.url,
        state: prData.state.toLowerCase() as PRInfo['state'],
        draft: prData.isDraft,
        mergeable: prData.mergeable === 'MERGEABLE' ? true : prData.mergeable === 'CONFLICTING' ? false : null,
        additions: prData.additions,
        deletions: prData.deletions,
        changedFiles: prData.changedFiles,
        createdAt: prData.createdAt,
        updatedAt: prData.updatedAt,
      };

      return NextResponse.json({
        branch: currentBranch,
        hasPR: true,
        pr: prInfo,
      });
    } catch {
      // No PR exists for this branch
      return NextResponse.json({
        branch: currentBranch,
        hasPR: false,
        pr: null,
      });
    }
  } catch (error) {
    console.error('Error getting PR status:', error);
    return NextResponse.json(
      { error: 'Failed to get PR status' },
      { status: 500 }
    );
  }
}

/**
 * POST /api/git/pr
 * Creates a new PR for the current branch
 *
 * Request body (optional):
 * - title: PR title (auto-generated if not provided)
 * - body: PR description (auto-generated if not provided)
 * - baseBranch: base branch (default: main)
 * - draft: create as draft PR (default: false)
 */
export async function POST(request: NextRequest) {
  try {
    // Check gh CLI
    if (!await checkGhCli()) {
      return NextResponse.json(
        { error: 'GitHub CLI (gh) is not installed' },
        { status: 500 }
      );
    }

    if (!await checkGhAuth()) {
      return NextResponse.json(
        { error: 'Not authenticated with GitHub. Run "gh auth login" first.' },
        { status: 401 }
      );
    }

    // Parse request body
    let title: string | undefined;
    let body: string | undefined;
    let baseBranch = 'main';
    let draft = false;

    try {
      const requestBody = await request.json();
      title = requestBody.title;
      body = requestBody.body;
      baseBranch = requestBody.baseBranch || 'main';
      draft = requestBody.draft || false;
    } catch {
      // Empty body is OK, use defaults
    }

    // Get current branch
    const { stdout: branchStdout } = await execAsync('git branch --show-current', {
      cwd: PROJECT_ROOT,
    });
    const currentBranch = branchStdout.trim();

    // Check if on main branch
    if (currentBranch === baseBranch) {
      return NextResponse.json(
        { error: `Cannot create PR from ${baseBranch} to ${baseBranch}` },
        { status: 400 }
      );
    }

    // Check if PR already exists
    try {
      const { stdout: existingPR } = await execAsync(
        `gh pr view --json url`,
        { cwd: PROJECT_ROOT }
      );
      const prData = JSON.parse(existingPR);

      return NextResponse.json({
        branch: currentBranch,
        created: false,
        message: 'PR already exists',
        url: prData.url,
      });
    } catch {
      // No existing PR, continue to create
    }

    // Generate title and body if not provided
    if (!title) {
      title = await generatePRTitle();
    }
    if (!body) {
      body = await generatePRDescription();
    }

    // Push current branch to remote first
    try {
      await execAsync(`git push -u origin ${currentBranch}`, { cwd: PROJECT_ROOT });
    } catch (pushError) {
      // Branch might already be pushed, try to continue
      console.warn('Push warning:', pushError);
    }

    // Create PR using gh CLI
    const draftFlag = draft ? '--draft' : '';

    // Write body to a temp file to avoid shell escaping issues
    const tempBodyFile = path.join(PROJECT_ROOT, '.pr-body-temp.md');
    await fs.writeFile(tempBodyFile, body, 'utf-8');

    try {
      const { stdout: prOutput } = await execAsync(
        `gh pr create --base ${baseBranch} --title "${title.replace(/"/g, '\\"')}" --body-file "${tempBodyFile}" ${draftFlag}`,
        { cwd: PROJECT_ROOT }
      );

      // Clean up temp file
      await fs.unlink(tempBodyFile).catch(() => {});

      // Get the PR URL from output
      const prUrl = prOutput.trim();

      // Get full PR info
      const { stdout: prJson } = await execAsync(
        `gh pr view --json number,title,url,state,isDraft,mergeable,additions,deletions,changedFiles,createdAt,updatedAt`,
        { cwd: PROJECT_ROOT }
      );

      const prData = JSON.parse(prJson);

      const prInfo: PRInfo = {
        number: prData.number,
        title: prData.title,
        url: prData.url,
        state: prData.state.toLowerCase() as PRInfo['state'],
        draft: prData.isDraft,
        mergeable: prData.mergeable === 'MERGEABLE' ? true : prData.mergeable === 'CONFLICTING' ? false : null,
        additions: prData.additions,
        deletions: prData.deletions,
        changedFiles: prData.changedFiles,
        createdAt: prData.createdAt,
        updatedAt: prData.updatedAt,
      };

      return NextResponse.json({
        branch: currentBranch,
        created: true,
        url: prUrl,
        pr: prInfo,
      });
    } catch (createError) {
      // Clean up temp file
      await fs.unlink(tempBodyFile).catch(() => {});

      throw createError;
    }
  } catch (error) {
    console.error('Error creating PR:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { error: `Failed to create PR: ${errorMessage}` },
      { status: 500 }
    );
  }
}
