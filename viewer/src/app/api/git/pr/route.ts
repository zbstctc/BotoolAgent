import { NextRequest, NextResponse } from 'next/server';
import { exec } from 'child_process';
import { promisify } from 'util';
import path from 'path';
import fs from 'fs/promises';
import { getProjectRoot, getProjectPrdJsonPath, getProjectProgressPath, normalizeProjectId } from '@/lib/project-root';
import { verifyCsrfProtection } from '@/lib/api-guard';

const execAsync = promisify(exec);

const PROJECT_ROOT = getProjectRoot();

interface PRInfo {
  number: number;
  title: string;
  url: string;
  state: 'open' | 'closed' | 'merged';
  draft: boolean;
  mergeable: boolean | null;
  additions: number;
  deletions: number;
  changedFiles: number;
  createdAt: string;
  updatedAt: string;
}

interface CompletedTask {
  id: string;
  title: string;
}

function isSafeGitRef(ref: string): boolean {
  return (
    /^[A-Za-z0-9._/-]+$/.test(ref) &&
    !ref.startsWith('-') &&
    !ref.includes('..') &&
    !ref.includes('//')
  );
}

function shellQuote(value: string): string {
  return `'${value.replace(/'/g, `'\\''`)}'`;
}

/**
 * Parse progress.txt to extract completed task IDs and titles
 */
async function getCompletedTasks(projectId?: string): Promise<CompletedTask[]> {
  const progressPath = getProjectProgressPath(projectId);
  const tasks: CompletedTask[] = [];

  try {
    const content = await fs.readFile(progressPath, 'utf-8');
    // Match pattern: ## DATE - TASK_ID
    const taskMatches = content.matchAll(/## [\d\-\/\:\s]+ - (DT-\d+)/g);

    for (const match of taskMatches) {
      tasks.push({
        id: match[1],
        title: '', // Will be filled from PRD
      });
    }
  } catch {
    // progress.txt might not exist
  }

  return tasks;
}

/**
 * Get task titles from prd.json
 */
async function getTaskTitles(taskIds: string[], projectId?: string): Promise<Map<string, string>> {
  const prdPath = getProjectPrdJsonPath(projectId);
  const titleMap = new Map<string, string>();

  try {
    const content = await fs.readFile(prdPath, 'utf-8');
    const prd = JSON.parse(content);

    if (prd.devTasks && Array.isArray(prd.devTasks)) {
      for (const task of prd.devTasks) {
        if (taskIds.includes(task.id)) {
          titleMap.set(task.id, task.title);
        }
      }
    }
  } catch {
    // prd.json might not exist or be invalid
  }

  return titleMap;
}

/**
 * Generate PR title from project name and branch
 */
async function generatePRTitle(projectId?: string): Promise<string> {
  const prdPath = getProjectPrdJsonPath(projectId);

  try {
    const content = await fs.readFile(prdPath, 'utf-8');
    const prd = JSON.parse(content);

    if (prd.project) {
      return `feat: ${prd.project}`;
    }
  } catch {
    // Use branch name as fallback
  }

  // Fallback: use branch name
  const { stdout } = await execAsync('git branch --show-current', { cwd: PROJECT_ROOT });
  const branch = stdout.trim();
  return `feat: ${branch}`;
}

/**
 * Generate PR description with completed tasks
 */
async function generatePRDescription(projectId?: string): Promise<string> {
  const completedTasks = await getCompletedTasks(projectId);
  const taskIds = completedTasks.map(t => t.id);
  const titleMap = await getTaskTitles(taskIds, projectId);

  // Fill in titles
  for (const task of completedTasks) {
    task.title = titleMap.get(task.id) || task.id;
  }

  // Get PRD description
  let projectDescription = '';
  try {
    const prdPath = getProjectPrdJsonPath(projectId);
    const content = await fs.readFile(prdPath, 'utf-8');
    const prd = JSON.parse(content);
    projectDescription = prd.description || '';
  } catch {
    // Ignore errors
  }

  // Build description
  const lines: string[] = [
    '## Summary',
    '',
    projectDescription || 'Automated PR created by BotoolAgent.',
    '',
  ];

  if (completedTasks.length > 0) {
    lines.push('## Completed Tasks');
    lines.push('');
    for (const task of completedTasks) {
      lines.push(`- [x] **${task.id}**: ${task.title}`);
    }
    lines.push('');
  }

  lines.push('---');
  lines.push('*Generated by BotoolAgent*');

  return lines.join('\n');
}

/**
 * Check if gh CLI is available
 */
async function checkGhCli(): Promise<boolean> {
  try {
    await execAsync('gh --version', { cwd: PROJECT_ROOT });
    return true;
  } catch {
    return false;
  }
}

/**
 * Check if user is authenticated with gh
 */
async function checkGhAuth(): Promise<boolean> {
  try {
    await execAsync('gh auth status', { cwd: PROJECT_ROOT });
    return true;
  } catch {
    return false;
  }
}

/**
 * Resolve the feature branch name for a project.
 * If projectId is given, reads branchName from tasks/{projectId}/prd.json.
 * Falls back to git branch --show-current (for non-worktree usage).
 */
async function resolveBranch(projectId?: string | null): Promise<string | null> {
  const safeId = normalizeProjectId(projectId);
  if (safeId) {
    try {
      const prdPath = getProjectPrdJsonPath(safeId);
      const content = await fs.readFile(prdPath, 'utf-8');
      const prd = JSON.parse(content);
      if (prd.branchName && isSafeGitRef(prd.branchName)) {
        return prd.branchName;
      }
    } catch {
      // prd.json not found or invalid — fall through to git fallback
    }
  }
  try {
    const { stdout } = await execAsync('git branch --show-current', { cwd: PROJECT_ROOT });
    return stdout.trim() || null;
  } catch {
    return null;
  }
}

/**
 * GET /api/git/pr?projectId=xxx
 * Returns the PR status for the project's feature branch.
 * In worktree model, resolves the branch from prd.json rather than git branch --show-current.
 * Also detects already-merged PRs (--state all).
 */
export async function GET(request: NextRequest) {
  try {
    // Check gh CLI
    if (!await checkGhCli()) {
      return NextResponse.json(
        { error: 'GitHub CLI (gh) is not installed' },
        { status: 500 }
      );
    }

    if (!await checkGhAuth()) {
      return NextResponse.json(
        { error: 'Not authenticated with GitHub. Run "gh auth login" first.' },
        { status: 401 }
      );
    }

    const url = new URL(request.url);
    const projectId = url.searchParams.get('projectId') || undefined;

    const currentBranch = await resolveBranch(projectId);
    if (!currentBranch) {
      return NextResponse.json(
        { error: 'Could not determine branch name' },
        { status: 400 }
      );
    }

    if (!isSafeGitRef(currentBranch)) {
      return NextResponse.json(
        { error: 'Unsafe branch name detected' },
        { status: 400 }
      );
    }

    // Find PR by branch using gh pr list --head (works from any branch, including main).
    // Use --state all so merged PRs are also returned.
    try {
      const { stdout: listJson } = await execAsync(
        `gh pr list --head ${shellQuote(currentBranch)} --json number --state all`,
        { cwd: PROJECT_ROOT }
      );
      const prList = JSON.parse(listJson);

      if (prList.length === 0) {
        return NextResponse.json({ branch: currentBranch, hasPR: false, pr: null });
      }

      // Get full PR details by number
      const prNumber = prList[0].number;
      const { stdout: prJson } = await execAsync(
        `gh pr view ${prNumber} --json number,title,url,state,isDraft,mergeable,additions,deletions,changedFiles,createdAt,updatedAt`,
        { cwd: PROJECT_ROOT }
      );

      const prData = JSON.parse(prJson);

      const prInfo: PRInfo = {
        number: prData.number,
        title: prData.title,
        url: prData.url,
        state: prData.state.toLowerCase() as PRInfo['state'],
        draft: prData.isDraft,
        mergeable: prData.mergeable === 'MERGEABLE' ? true : prData.mergeable === 'CONFLICTING' ? false : null,
        additions: prData.additions,
        deletions: prData.deletions,
        changedFiles: prData.changedFiles,
        createdAt: prData.createdAt,
        updatedAt: prData.updatedAt,
      };

      return NextResponse.json({
        branch: currentBranch,
        hasPR: true,
        pr: prInfo,
      });
    } catch {
      // No PR exists for this branch
      return NextResponse.json({
        branch: currentBranch,
        hasPR: false,
        pr: null,
      });
    }
  } catch (error) {
    console.error('Error getting PR status:', error);
    return NextResponse.json(
      { error: 'Failed to get PR status' },
      { status: 500 }
    );
  }
}

/**
 * POST /api/git/pr
 * Creates a new PR for the current branch
 *
 * Request body (optional):
 * - title: PR title (auto-generated if not provided)
 * - body: PR description (auto-generated if not provided)
 * - baseBranch: base branch (default: main)
 * - draft: create as draft PR (default: false)
 */
export async function POST(request: NextRequest) {
  const csrfError = verifyCsrfProtection(request);
  if (csrfError) return csrfError;

  try {
    // Check gh CLI
    if (!await checkGhCli()) {
      return NextResponse.json(
        { error: 'GitHub CLI (gh) is not installed' },
        { status: 500 }
      );
    }

    if (!await checkGhAuth()) {
      return NextResponse.json(
        { error: 'Not authenticated with GitHub. Run "gh auth login" first.' },
        { status: 401 }
      );
    }

    // Parse request body
    let title: string | undefined;
    let body: string | undefined;
    let baseBranch = 'main';
    let draft = false;

    let projectId: string | undefined;

    try {
      const requestBody = await request.json();
      title = requestBody.title;
      body = requestBody.body;
      baseBranch = requestBody.baseBranch || 'main';
      draft = requestBody.draft || false;
      projectId = requestBody.projectId;
    } catch {
      // Empty body is OK, use defaults
    }

    if (!isSafeGitRef(baseBranch)) {
      return NextResponse.json(
        { error: 'Invalid baseBranch' },
        { status: 400 }
      );
    }

    // Resolve branch: use projectId → prd.json → branchName, or fall back to git
    const currentBranch = await resolveBranch(projectId);
    if (!currentBranch) {
      return NextResponse.json(
        { error: 'Could not determine branch name' },
        { status: 400 }
      );
    }

    if (!isSafeGitRef(currentBranch)) {
      return NextResponse.json(
        { error: 'Unsafe branch name detected' },
        { status: 400 }
      );
    }

    // Check if on main branch
    if (currentBranch === baseBranch) {
      return NextResponse.json(
        { error: `Cannot create PR from ${baseBranch} to ${baseBranch}` },
        { status: 400 }
      );
    }

    // Check if PR already exists (search by branch name, works from any branch)
    try {
      const { stdout: listJson } = await execAsync(
        `gh pr list --head ${shellQuote(currentBranch)} --json number,url`,
        { cwd: PROJECT_ROOT }
      );
      const prList = JSON.parse(listJson);
      if (prList.length > 0) {
        const prData = prList[0];
        return NextResponse.json({
          branch: currentBranch,
          created: false,
          message: 'PR already exists',
          url: prData.url,
        });
      }
    } catch {
      // No existing PR, continue to create
    }

    // Generate title and body if not provided
    if (!title) {
      title = await generatePRTitle(projectId);
    }
    if (!body) {
      body = await generatePRDescription(projectId);
    }

    // Push current branch to remote first
    try {
      await execAsync(`git push -u origin ${shellQuote(currentBranch)}`, { cwd: PROJECT_ROOT });
    } catch (pushError) {
      // Branch might already be pushed, try to continue
      console.warn('Push warning:', pushError);
    }

    // Create PR using gh CLI
    const draftFlag = draft ? '--draft' : '';

    // Write body to a temp file to avoid shell escaping issues
    const tempBodyFile = path.join(PROJECT_ROOT, '.pr-body-temp.md');
    await fs.writeFile(tempBodyFile, body, 'utf-8');

    try {
      const createCmd = [
        'gh pr create',
        `--base ${shellQuote(baseBranch)}`,
        `--title ${shellQuote(title)}`,
        `--body-file ${shellQuote(tempBodyFile)}`,
        draftFlag,
      ].filter(Boolean).join(' ');

      const { stdout: prOutput } = await execAsync(
        createCmd,
        { cwd: PROJECT_ROOT }
      );

      // Clean up temp file
      await fs.unlink(tempBodyFile).catch(() => {});

      // Get the PR URL from output
      const prUrl = prOutput.trim();

      // Get full PR info by looking up by branch (just created, so should exist)
      const { stdout: newPrListJson } = await execAsync(
        `gh pr list --head ${shellQuote(currentBranch)} --json number`,
        { cwd: PROJECT_ROOT }
      );
      const newPrList = JSON.parse(newPrListJson);
      const newPrNumber = newPrList.length > 0 ? newPrList[0].number : undefined;

      const { stdout: prJson } = await execAsync(
        `gh pr view ${newPrNumber ?? ''} --json number,title,url,state,isDraft,mergeable,additions,deletions,changedFiles,createdAt,updatedAt`,
        { cwd: PROJECT_ROOT }
      );

      const prData = JSON.parse(prJson);

      const prInfo: PRInfo = {
        number: prData.number,
        title: prData.title,
        url: prData.url,
        state: prData.state.toLowerCase() as PRInfo['state'],
        draft: prData.isDraft,
        mergeable: prData.mergeable === 'MERGEABLE' ? true : prData.mergeable === 'CONFLICTING' ? false : null,
        additions: prData.additions,
        deletions: prData.deletions,
        changedFiles: prData.changedFiles,
        createdAt: prData.createdAt,
        updatedAt: prData.updatedAt,
      };

      return NextResponse.json({
        branch: currentBranch,
        created: true,
        url: prUrl,
        pr: prInfo,
      });
    } catch (createError) {
      // Clean up temp file
      await fs.unlink(tempBodyFile).catch(() => {});

      throw createError;
    }
  } catch (error) {
    console.error('Error creating PR:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { error: `Failed to create PR: ${errorMessage}` },
      { status: 500 }
    );
  }
}
